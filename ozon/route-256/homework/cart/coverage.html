
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">route256/cart/cmd/config/config.go (75.0%)</option>
				
				<option value="file1">route256/cart/cmd/main.go (0.0%)</option>
				
				<option value="file2">route256/cart/internal/handler/handler.go (39.2%)</option>
				
				<option value="file3">route256/cart/internal/handler/middleware.go (0.0%)</option>
				
				<option value="file4">route256/cart/internal/repository/repository.go (100.0%)</option>
				
				<option value="file5">route256/cart/internal/service/mocks/cart_repository_mock.go (26.7%)</option>
				
				<option value="file6">route256/cart/internal/service/mocks/product_client_mock.go (34.0%)</option>
				
				<option value="file7">route256/cart/internal/service/service.go (96.0%)</option>
				
				<option value="file8">route256/cart/pkg/product/product.go (70.0%)</option>
				
				<option value="file9">route256/cart/tests/handler/setup.go (85.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "github.com/caarlos0/env/v11"
)

type ServerConfig struct {
        Port string `env:"PORT,required"`
}

type ProductClient struct {
        Host    string `env:"PRODUCT_HOST,required"`
        Token   string `env:"PRODUCT_TOKEN,required"`
        Timeout string `env:"PRODUCT_TIMEOUT,required"`
}

type Config struct {
        ServerConfig  ServerConfig
        ProductClient ProductClient
}

func NewConfig() (Config, error) <span class="cov8" title="1">{
        cfg := Config{}

        if err := env.Parse(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return cfg, err
        }</span>

        <span class="cov8" title="1">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log"
        "log/slog"
        "net/http"
        "time"

        "route256/cart/cmd/config"
        "route256/cart/internal/handler"
        "route256/cart/internal/repository"
        "route256/cart/internal/service"
        "route256/cart/pkg/product"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to parse config: %s", err)
        }</span>

        <span class="cov0" title="0">productClientTimeout, err := time.ParseDuration(cfg.ProductClient.Timeout + "s")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to parse product client timeout: %s", err)
        }</span>

        <span class="cov0" title="0">router := http.NewServeMux()
        productClient := product.NewClient(cfg.ProductClient.Host, cfg.ProductClient.Token, productClientTimeout)

        repo := repository.NewRepository()
        serv := service.NewService(repo, productClient)
        hand := handler.NewHandler(serv)
        hand.RegisterRoutes(router)
        loggedMux := handler.LoggingMiddleware(router)

        server := &amp;http.Server{
                Addr:         ":" + cfg.ServerConfig.Port,
                Handler:      loggedMux,
                ReadTimeout:  10 * time.Second,
                WriteTimeout: 10 * time.Second,
                IdleTimeout:  15 * time.Second,
        }

        slog.Info("Starting server", slog.String("port", cfg.ServerConfig.Port))
        if err := server.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to start server", slog.String("error", err.Error()))
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handler

import (
        "context"
        "encoding/json"
        "net/http"
        "strconv"

        "route256/cart/internal/models"

        "github.com/go-playground/validator/v10"
)

type cartService interface {
        AddItemToUserCart(ctx context.Context, cart models.CartRequest) error
        DeleteItemFromUserCart(ctx context.Context, userID, skuID int64) error
        ClearUserCart(ctx context.Context, userID int64) error
        ListUserCart(ctx context.Context, userID int64) ([]models.CartItem, uint32, error)
}

type Handler struct {
        service  cartService
        validate *validator.Validate
}

func NewHandler(service cartService) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                service:  service,
                validate: validator.New(),
        }
}</span>

func (h *Handler) RegisterRoutes(mux *http.ServeMux) <span class="cov8" title="1">{
        mux.HandleFunc("POST /user/{userID}/cart/{skuID}", h.AddItemToUserCart)
        mux.HandleFunc("DELETE /user/{userID}/cart/{skuID}", h.DeleteItemFromUserCart)
        mux.HandleFunc("DELETE /user/{userID}/cart", h.ClearUserCart)
        mux.HandleFunc("GET /user/{userID}/cart", h.ListUserCart)
}</span>

func (h *Handler) extractUserID(w http.ResponseWriter, r *http.Request) (int64, bool) <span class="cov8" title="1">{
        userID, err := strconv.ParseInt(r.PathValue("userID"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid user ID", http.StatusBadRequest)
                return 0, false
        }</span>

        <span class="cov8" title="1">return userID, true</span>
}

func (h *Handler) extractPathParams(w http.ResponseWriter, r *http.Request) (int64, int64, bool) <span class="cov8" title="1">{
        userID, err := strconv.ParseInt(r.PathValue("userID"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid user ID", http.StatusBadRequest)
                return 0, 0, false
        }</span>

        <span class="cov8" title="1">skuID, err := strconv.ParseInt(r.PathValue("skuID"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid SKU ID", http.StatusBadRequest)
                return 0, 0, false
        }</span>

        <span class="cov8" title="1">return userID, skuID, true</span>
}

func (h *Handler) AddItemToUserCart(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID, skuID, ok := h.extractPathParams(w, r)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">req := models.CartRequest{
                UserID: userID,
                SkuID:  skuID,
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.validate.Struct(req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.AddItemToUserCart(r.Context(), req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
}

func (h *Handler) DeleteItemFromUserCart(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, skuID, ok := h.extractPathParams(w, r)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">req := models.CartRequest{
                UserID: userID,
                SkuID:  skuID,
        }

        if err := h.validate.StructPartial(req, "UserID", "SkuID"); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.service.DeleteItemFromUserCart(r.Context(), req.UserID, req.SkuID); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *Handler) ClearUserCart(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID, ok := h.extractUserID(w, r)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">req := models.CartRequest{
                UserID: userID,
        }

        if err := h.validate.StructPartial(req, "UserID"); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.ClearUserCart(r.Context(), req.UserID); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *Handler) ListUserCart(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, ok := h.extractUserID(w, r)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">req := models.CartRequest{
                UserID: userID,
        }

        if err := h.validate.StructPartial(req, "UserID"); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">items, totalPrice, err := h.service.ListUserCart(r.Context(), req.UserID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if len(items) == 0 </span><span class="cov0" title="0">{
                http.Error(w, "cart not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">response := struct {
                Items      []models.CartItem `json:"items"`
                TotalPrice uint32            `json:"total_price"`
        }{
                Items:      items,
                TotalPrice: totalPrice,
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "failed to encode response", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "log/slog"
        "net/http"
)

type statusRecorder struct {
        http.ResponseWriter
        status      int
        wroteHeader bool
}

func (rec *statusRecorder) WriteHeader(status int) <span class="cov0" title="0">{
        if !rec.wroteHeader </span><span class="cov0" title="0">{
                rec.status = status
                rec.ResponseWriter.WriteHeader(status)
                rec.wroteHeader = true
        }</span>
}

func (rec *statusRecorder) Write(b []byte) (int, error) <span class="cov0" title="0">{
        if !rec.wroteHeader </span><span class="cov0" title="0">{
                rec.WriteHeader(http.StatusOK)
        }</span>
        <span class="cov0" title="0">return rec.ResponseWriter.Write(b)</span>
}

func LoggingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                rec := &amp;statusRecorder{ResponseWriter: w}

                defer func() </span><span class="cov0" title="0">{
                        if rec.status &gt;= 400 </span><span class="cov0" title="0">{
                                slog.Error("HTTP request failed", "method", r.Method, "path", r.URL.Path, "status", rec.status)
                        }</span>
                }()

                <span class="cov0" title="0">next.ServeHTTP(rec, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package repository

import (
        "context"
        "fmt"
        "sync"

        "route256/cart/internal/models"
)

type Repository struct {
        carts map[int64]map[int64]uint16 // userID -&gt; skuID -&gt; count
        mu    sync.Mutex
}

func NewRepository() *Repository <span class="cov8" title="1">{
        return &amp;Repository{carts: make(map[int64]map[int64]uint16)}
}</span>

func (r *Repository) AddItemToUserCart(ctx context.Context, cart models.CartRequest) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        if r.carts[cart.UserID] == nil </span><span class="cov8" title="1">{
                r.carts[cart.UserID] = make(map[int64]uint16)
        }</span>

        <span class="cov8" title="1">r.carts[cart.UserID][cart.SkuID] += cart.Count

        return nil</span>
}

func (r *Repository) DeleteItemFromUserCart(ctx context.Context, userID, skuID int64) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        fmt.Println("DeleteItemFromUserCart", userID, skuID)
        fmt.Println(r.carts)
        delete(r.carts[userID], skuID)

        fmt.Println("\nsdsd", r.carts[userID])

        return nil
}</span>

func (r *Repository) ClearUserCart(ctx context.Context, userID int64) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        delete(r.carts, userID)

        return nil
}</span>

func (r *Repository) ListUserCart(ctx context.Context, userID int64) ([]models.CartItem, error) <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        userCart, exists := r.carts[userID]
        if !exists || len(userCart) == 0 </span><span class="cov8" title="1">{
                return nil, models.ErrCartIsEmpty
        }</span>

        <span class="cov8" title="1">items := make([]models.CartItem, 0, len(userCart))
        for skuID, count := range userCart </span><span class="cov8" title="1">{
                items = append(items,
                        models.CartItem{
                                SkuID: skuID,
                                Count: count,
                        })
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/cart/internal/service.cartRepository -o cart_repository_mock.go -n CartRepositoryMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "route256/cart/internal/models"

        "github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements service.cartRepository
type CartRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcAddItemToUserCart          func(ctx context.Context, cart models.CartRequest) (err error)
        inspectFuncAddItemToUserCart   func(ctx context.Context, cart models.CartRequest)
        afterAddItemToUserCartCounter  uint64
        beforeAddItemToUserCartCounter uint64
        AddItemToUserCartMock          mCartRepositoryMockAddItemToUserCart

        funcClearUserCart          func(ctx context.Context, userID int64) (err error)
        inspectFuncClearUserCart   func(ctx context.Context, userID int64)
        afterClearUserCartCounter  uint64
        beforeClearUserCartCounter uint64
        ClearUserCartMock          mCartRepositoryMockClearUserCart

        funcDeleteItemFromUserCart          func(ctx context.Context, userID int64, skuID int64) (err error)
        inspectFuncDeleteItemFromUserCart   func(ctx context.Context, userID int64, skuID int64)
        afterDeleteItemFromUserCartCounter  uint64
        beforeDeleteItemFromUserCartCounter uint64
        DeleteItemFromUserCartMock          mCartRepositoryMockDeleteItemFromUserCart

        funcListUserCart          func(ctx context.Context, userID int64) (ca1 []models.CartItem, err error)
        inspectFuncListUserCart   func(ctx context.Context, userID int64)
        afterListUserCartCounter  uint64
        beforeListUserCartCounter uint64
        ListUserCartMock          mCartRepositoryMockListUserCart
}

// NewCartRepositoryMock returns a mock for service.cartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock <span class="cov8" title="1">{
        m := &amp;CartRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="1">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="1">m.AddItemToUserCartMock = mCartRepositoryMockAddItemToUserCart{mock: m}
        m.AddItemToUserCartMock.callArgs = []*CartRepositoryMockAddItemToUserCartParams{}

        m.ClearUserCartMock = mCartRepositoryMockClearUserCart{mock: m}
        m.ClearUserCartMock.callArgs = []*CartRepositoryMockClearUserCartParams{}

        m.DeleteItemFromUserCartMock = mCartRepositoryMockDeleteItemFromUserCart{mock: m}
        m.DeleteItemFromUserCartMock.callArgs = []*CartRepositoryMockDeleteItemFromUserCartParams{}

        m.ListUserCartMock = mCartRepositoryMockListUserCart{mock: m}
        m.ListUserCartMock.callArgs = []*CartRepositoryMockListUserCartParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mCartRepositoryMockAddItemToUserCart struct {
        optional           bool
        mock               *CartRepositoryMock
        defaultExpectation *CartRepositoryMockAddItemToUserCartExpectation
        expectations       []*CartRepositoryMockAddItemToUserCartExpectation

        callArgs []*CartRepositoryMockAddItemToUserCartParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// CartRepositoryMockAddItemToUserCartExpectation specifies expectation struct of the cartRepository.AddItemToUserCart
type CartRepositoryMockAddItemToUserCartExpectation struct {
        mock      *CartRepositoryMock
        params    *CartRepositoryMockAddItemToUserCartParams
        paramPtrs *CartRepositoryMockAddItemToUserCartParamPtrs
        results   *CartRepositoryMockAddItemToUserCartResults
        Counter   uint64
}

// CartRepositoryMockAddItemToUserCartParams contains parameters of the cartRepository.AddItemToUserCart
type CartRepositoryMockAddItemToUserCartParams struct {
        ctx  context.Context
        cart models.CartRequest
}

// CartRepositoryMockAddItemToUserCartParamPtrs contains pointers to parameters of the cartRepository.AddItemToUserCart
type CartRepositoryMockAddItemToUserCartParamPtrs struct {
        ctx  *context.Context
        cart *models.CartRequest
}

// CartRepositoryMockAddItemToUserCartResults contains results of the cartRepository.AddItemToUserCart
type CartRepositoryMockAddItemToUserCartResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Optional() *mCartRepositoryMockAddItemToUserCart <span class="cov0" title="0">{
        mmAddItemToUserCart.optional = true
        return mmAddItemToUserCart
}</span>

// Expect sets up expected params for cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Expect(ctx context.Context, cart models.CartRequest) *mCartRepositoryMockAddItemToUserCart <span class="cov0" title="0">{
        if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.defaultExpectation = &amp;CartRepositoryMockAddItemToUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmAddItemToUserCart.defaultExpectation.params = &amp;CartRepositoryMockAddItemToUserCartParams{ctx, cart}
        for _, e := range mmAddItemToUserCart.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmAddItemToUserCart.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmAddItemToUserCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItemToUserCart.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmAddItemToUserCart</span>
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockAddItemToUserCart <span class="cov0" title="0">{
        if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.defaultExpectation = &amp;CartRepositoryMockAddItemToUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockAddItemToUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAddItemToUserCart.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmAddItemToUserCart</span>
}

// ExpectCartParam2 sets up expected param cart for cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) ExpectCartParam2(cart models.CartRequest) *mCartRepositoryMockAddItemToUserCart <span class="cov0" title="0">{
        if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.defaultExpectation = &amp;CartRepositoryMockAddItemToUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockAddItemToUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAddItemToUserCart.defaultExpectation.paramPtrs.cart = &amp;cart

        return mmAddItemToUserCart</span>
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Inspect(f func(ctx context.Context, cart models.CartRequest)) *mCartRepositoryMockAddItemToUserCart <span class="cov0" title="0">{
        if mmAddItemToUserCart.mock.inspectFuncAddItemToUserCart != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.AddItemToUserCart")
        }</span>

        <span class="cov0" title="0">mmAddItemToUserCart.mock.inspectFuncAddItemToUserCart = f

        return mmAddItemToUserCart</span>
}

// Return sets up results that will be returned by cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Return(err error) *CartRepositoryMock <span class="cov8" title="1">{
        if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmAddItemToUserCart.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmAddItemToUserCart.defaultExpectation = &amp;CartRepositoryMockAddItemToUserCartExpectation{mock: mmAddItemToUserCart.mock}
        }</span>
        <span class="cov8" title="1">mmAddItemToUserCart.defaultExpectation.results = &amp;CartRepositoryMockAddItemToUserCartResults{err}
        return mmAddItemToUserCart.mock</span>
}

// Set uses given function f to mock the cartRepository.AddItemToUserCart method
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Set(f func(ctx context.Context, cart models.CartRequest) (err error)) *CartRepositoryMock <span class="cov0" title="0">{
        if mmAddItemToUserCart.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("Default expectation is already set for the cartRepository.AddItemToUserCart method")
        }</span>

        <span class="cov0" title="0">if len(mmAddItemToUserCart.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("Some expectations are already set for the cartRepository.AddItemToUserCart method")
        }</span>

        <span class="cov0" title="0">mmAddItemToUserCart.mock.funcAddItemToUserCart = f
        return mmAddItemToUserCart.mock</span>
}

// When sets expectation for the cartRepository.AddItemToUserCart which will trigger the result defined by the following
// Then helper
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) When(ctx context.Context, cart models.CartRequest) *CartRepositoryMockAddItemToUserCartExpectation <span class="cov0" title="0">{
        if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CartRepositoryMockAddItemToUserCartExpectation{
                mock:   mmAddItemToUserCart.mock,
                params: &amp;CartRepositoryMockAddItemToUserCartParams{ctx, cart},
        }
        mmAddItemToUserCart.expectations = append(mmAddItemToUserCart.expectations, expectation)
        return expectation</span>
}

// Then sets up cartRepository.AddItemToUserCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddItemToUserCartExpectation) Then(err error) *CartRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;CartRepositoryMockAddItemToUserCartResults{err}
        return e.mock
}</span>

// Times sets number of times cartRepository.AddItemToUserCart should be invoked
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Times(n uint64) *mCartRepositoryMockAddItemToUserCart <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("Times of CartRepositoryMock.AddItemToUserCart mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmAddItemToUserCart.expectedInvocations, n)
        return mmAddItemToUserCart</span>
}

func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmAddItemToUserCart.expectations) == 0 &amp;&amp; mmAddItemToUserCart.defaultExpectation == nil &amp;&amp; mmAddItemToUserCart.mock.funcAddItemToUserCart == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmAddItemToUserCart.mock.afterAddItemToUserCartCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmAddItemToUserCart.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// AddItemToUserCart implements service.cartRepository
func (mmAddItemToUserCart *CartRepositoryMock) AddItemToUserCart(ctx context.Context, cart models.CartRequest) (err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmAddItemToUserCart.beforeAddItemToUserCartCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmAddItemToUserCart.afterAddItemToUserCartCounter, 1)

        if mmAddItemToUserCart.inspectFuncAddItemToUserCart != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.inspectFuncAddItemToUserCart(ctx, cart)
        }</span>

        <span class="cov8" title="1">mm_params := CartRepositoryMockAddItemToUserCartParams{ctx, cart}

        // Record call args
        mmAddItemToUserCart.AddItemToUserCartMock.mutex.Lock()
        mmAddItemToUserCart.AddItemToUserCartMock.callArgs = append(mmAddItemToUserCart.AddItemToUserCartMock.callArgs, &amp;mm_params)
        mmAddItemToUserCart.AddItemToUserCartMock.mutex.Unlock()

        for _, e := range mmAddItemToUserCart.AddItemToUserCartMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation.Counter, 1)
                mm_want := mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation.params
                mm_want_ptrs := mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation.paramPtrs

                mm_got := CartRepositoryMockAddItemToUserCartParams{ctx, cart}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmAddItemToUserCart.t.Errorf("CartRepositoryMock.AddItemToUserCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.cart != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.cart, mm_got.cart) </span><span class="cov0" title="0">{
                                mmAddItemToUserCart.t.Errorf("CartRepositoryMock.AddItemToUserCart got unexpected parameter cart, want: %#v, got: %#v%s\n", *mm_want_ptrs.cart, mm_got.cart, minimock.Diff(*mm_want_ptrs.cart, mm_got.cart))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmAddItemToUserCart.t.Errorf("CartRepositoryMock.AddItemToUserCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmAddItemToUserCart.t.Fatal("No results are set for the CartRepositoryMock.AddItemToUserCart")
                }</span>
                <span class="cov8" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmAddItemToUserCart.funcAddItemToUserCart != nil </span><span class="cov0" title="0">{
                return mmAddItemToUserCart.funcAddItemToUserCart(ctx, cart)
        }</span>
        <span class="cov0" title="0">mmAddItemToUserCart.t.Fatalf("Unexpected call to CartRepositoryMock.AddItemToUserCart. %v %v", ctx, cart)
        return</span>
}

// AddItemToUserCartAfterCounter returns a count of finished CartRepositoryMock.AddItemToUserCart invocations
func (mmAddItemToUserCart *CartRepositoryMock) AddItemToUserCartAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAddItemToUserCart.afterAddItemToUserCartCounter)
}</span>

// AddItemToUserCartBeforeCounter returns a count of CartRepositoryMock.AddItemToUserCart invocations
func (mmAddItemToUserCart *CartRepositoryMock) AddItemToUserCartBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAddItemToUserCart.beforeAddItemToUserCartCounter)
}</span>

// Calls returns a list of arguments used in each call to CartRepositoryMock.AddItemToUserCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Calls() []*CartRepositoryMockAddItemToUserCartParams <span class="cov0" title="0">{
        mmAddItemToUserCart.mutex.RLock()

        argCopy := make([]*CartRepositoryMockAddItemToUserCartParams, len(mmAddItemToUserCart.callArgs))
        copy(argCopy, mmAddItemToUserCart.callArgs)

        mmAddItemToUserCart.mutex.RUnlock()

        return argCopy
}</span>

// MinimockAddItemToUserCartDone returns true if the count of the AddItemToUserCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddItemToUserCartDone() bool <span class="cov8" title="1">{
        if m.AddItemToUserCartMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.AddItemToUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.AddItemToUserCartMock.invocationsDone()</span>
}

// MinimockAddItemToUserCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddItemToUserCartInspect() <span class="cov0" title="0">{
        for _, e := range m.AddItemToUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CartRepositoryMock.AddItemToUserCart with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterAddItemToUserCartCounter := mm_atomic.LoadUint64(&amp;m.afterAddItemToUserCartCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.AddItemToUserCartMock.defaultExpectation != nil &amp;&amp; afterAddItemToUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.AddItemToUserCartMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to CartRepositoryMock.AddItemToUserCart")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CartRepositoryMock.AddItemToUserCart with params: %#v", *m.AddItemToUserCartMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcAddItemToUserCart != nil &amp;&amp; afterAddItemToUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to CartRepositoryMock.AddItemToUserCart")
        }</span>

        <span class="cov0" title="0">if !m.AddItemToUserCartMock.invocationsDone() &amp;&amp; afterAddItemToUserCartCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CartRepositoryMock.AddItemToUserCart but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.AddItemToUserCartMock.expectedInvocations), afterAddItemToUserCartCounter)
        }</span>
}

type mCartRepositoryMockClearUserCart struct {
        optional           bool
        mock               *CartRepositoryMock
        defaultExpectation *CartRepositoryMockClearUserCartExpectation
        expectations       []*CartRepositoryMockClearUserCartExpectation

        callArgs []*CartRepositoryMockClearUserCartParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// CartRepositoryMockClearUserCartExpectation specifies expectation struct of the cartRepository.ClearUserCart
type CartRepositoryMockClearUserCartExpectation struct {
        mock      *CartRepositoryMock
        params    *CartRepositoryMockClearUserCartParams
        paramPtrs *CartRepositoryMockClearUserCartParamPtrs
        results   *CartRepositoryMockClearUserCartResults
        Counter   uint64
}

// CartRepositoryMockClearUserCartParams contains parameters of the cartRepository.ClearUserCart
type CartRepositoryMockClearUserCartParams struct {
        ctx    context.Context
        userID int64
}

// CartRepositoryMockClearUserCartParamPtrs contains pointers to parameters of the cartRepository.ClearUserCart
type CartRepositoryMockClearUserCartParamPtrs struct {
        ctx    *context.Context
        userID *int64
}

// CartRepositoryMockClearUserCartResults contains results of the cartRepository.ClearUserCart
type CartRepositoryMockClearUserCartResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Optional() *mCartRepositoryMockClearUserCart <span class="cov0" title="0">{
        mmClearUserCart.optional = true
        return mmClearUserCart
}</span>

// Expect sets up expected params for cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Expect(ctx context.Context, userID int64) *mCartRepositoryMockClearUserCart <span class="cov0" title="0">{
        if mmClearUserCart.mock.funcClearUserCart != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmClearUserCart.defaultExpectation = &amp;CartRepositoryMockClearUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmClearUserCart.defaultExpectation.params = &amp;CartRepositoryMockClearUserCartParams{ctx, userID}
        for _, e := range mmClearUserCart.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmClearUserCart.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmClearUserCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearUserCart.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmClearUserCart</span>
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockClearUserCart <span class="cov0" title="0">{
        if mmClearUserCart.mock.funcClearUserCart != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmClearUserCart.defaultExpectation = &amp;CartRepositoryMockClearUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmClearUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockClearUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmClearUserCart.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmClearUserCart</span>
}

// ExpectUserIDParam2 sets up expected param userID for cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) ExpectUserIDParam2(userID int64) *mCartRepositoryMockClearUserCart <span class="cov0" title="0">{
        if mmClearUserCart.mock.funcClearUserCart != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmClearUserCart.defaultExpectation = &amp;CartRepositoryMockClearUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmClearUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockClearUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmClearUserCart.defaultExpectation.paramPtrs.userID = &amp;userID

        return mmClearUserCart</span>
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Inspect(f func(ctx context.Context, userID int64)) *mCartRepositoryMockClearUserCart <span class="cov0" title="0">{
        if mmClearUserCart.mock.inspectFuncClearUserCart != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ClearUserCart")
        }</span>

        <span class="cov0" title="0">mmClearUserCart.mock.inspectFuncClearUserCart = f

        return mmClearUserCart</span>
}

// Return sets up results that will be returned by cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Return(err error) *CartRepositoryMock <span class="cov8" title="1">{
        if mmClearUserCart.mock.funcClearUserCart != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmClearUserCart.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmClearUserCart.defaultExpectation = &amp;CartRepositoryMockClearUserCartExpectation{mock: mmClearUserCart.mock}
        }</span>
        <span class="cov8" title="1">mmClearUserCart.defaultExpectation.results = &amp;CartRepositoryMockClearUserCartResults{err}
        return mmClearUserCart.mock</span>
}

// Set uses given function f to mock the cartRepository.ClearUserCart method
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Set(f func(ctx context.Context, userID int64) (err error)) *CartRepositoryMock <span class="cov0" title="0">{
        if mmClearUserCart.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("Default expectation is already set for the cartRepository.ClearUserCart method")
        }</span>

        <span class="cov0" title="0">if len(mmClearUserCart.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("Some expectations are already set for the cartRepository.ClearUserCart method")
        }</span>

        <span class="cov0" title="0">mmClearUserCart.mock.funcClearUserCart = f
        return mmClearUserCart.mock</span>
}

// When sets expectation for the cartRepository.ClearUserCart which will trigger the result defined by the following
// Then helper
func (mmClearUserCart *mCartRepositoryMockClearUserCart) When(ctx context.Context, userID int64) *CartRepositoryMockClearUserCartExpectation <span class="cov0" title="0">{
        if mmClearUserCart.mock.funcClearUserCart != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CartRepositoryMockClearUserCartExpectation{
                mock:   mmClearUserCart.mock,
                params: &amp;CartRepositoryMockClearUserCartParams{ctx, userID},
        }
        mmClearUserCart.expectations = append(mmClearUserCart.expectations, expectation)
        return expectation</span>
}

// Then sets up cartRepository.ClearUserCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockClearUserCartExpectation) Then(err error) *CartRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;CartRepositoryMockClearUserCartResults{err}
        return e.mock
}</span>

// Times sets number of times cartRepository.ClearUserCart should be invoked
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Times(n uint64) *mCartRepositoryMockClearUserCart <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("Times of CartRepositoryMock.ClearUserCart mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmClearUserCart.expectedInvocations, n)
        return mmClearUserCart</span>
}

func (mmClearUserCart *mCartRepositoryMockClearUserCart) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmClearUserCart.expectations) == 0 &amp;&amp; mmClearUserCart.defaultExpectation == nil &amp;&amp; mmClearUserCart.mock.funcClearUserCart == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmClearUserCart.mock.afterClearUserCartCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmClearUserCart.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ClearUserCart implements service.cartRepository
func (mmClearUserCart *CartRepositoryMock) ClearUserCart(ctx context.Context, userID int64) (err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmClearUserCart.beforeClearUserCartCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmClearUserCart.afterClearUserCartCounter, 1)

        if mmClearUserCart.inspectFuncClearUserCart != nil </span><span class="cov0" title="0">{
                mmClearUserCart.inspectFuncClearUserCart(ctx, userID)
        }</span>

        <span class="cov8" title="1">mm_params := CartRepositoryMockClearUserCartParams{ctx, userID}

        // Record call args
        mmClearUserCart.ClearUserCartMock.mutex.Lock()
        mmClearUserCart.ClearUserCartMock.callArgs = append(mmClearUserCart.ClearUserCartMock.callArgs, &amp;mm_params)
        mmClearUserCart.ClearUserCartMock.mutex.Unlock()

        for _, e := range mmClearUserCart.ClearUserCartMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmClearUserCart.ClearUserCartMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmClearUserCart.ClearUserCartMock.defaultExpectation.Counter, 1)
                mm_want := mmClearUserCart.ClearUserCartMock.defaultExpectation.params
                mm_want_ptrs := mmClearUserCart.ClearUserCartMock.defaultExpectation.paramPtrs

                mm_got := CartRepositoryMockClearUserCartParams{ctx, userID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmClearUserCart.t.Errorf("CartRepositoryMock.ClearUserCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.userID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) </span><span class="cov0" title="0">{
                                mmClearUserCart.t.Errorf("CartRepositoryMock.ClearUserCart got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmClearUserCart.t.Errorf("CartRepositoryMock.ClearUserCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmClearUserCart.ClearUserCartMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmClearUserCart.t.Fatal("No results are set for the CartRepositoryMock.ClearUserCart")
                }</span>
                <span class="cov8" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmClearUserCart.funcClearUserCart != nil </span><span class="cov0" title="0">{
                return mmClearUserCart.funcClearUserCart(ctx, userID)
        }</span>
        <span class="cov0" title="0">mmClearUserCart.t.Fatalf("Unexpected call to CartRepositoryMock.ClearUserCart. %v %v", ctx, userID)
        return</span>
}

// ClearUserCartAfterCounter returns a count of finished CartRepositoryMock.ClearUserCart invocations
func (mmClearUserCart *CartRepositoryMock) ClearUserCartAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmClearUserCart.afterClearUserCartCounter)
}</span>

// ClearUserCartBeforeCounter returns a count of CartRepositoryMock.ClearUserCart invocations
func (mmClearUserCart *CartRepositoryMock) ClearUserCartBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmClearUserCart.beforeClearUserCartCounter)
}</span>

// Calls returns a list of arguments used in each call to CartRepositoryMock.ClearUserCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Calls() []*CartRepositoryMockClearUserCartParams <span class="cov0" title="0">{
        mmClearUserCart.mutex.RLock()

        argCopy := make([]*CartRepositoryMockClearUserCartParams, len(mmClearUserCart.callArgs))
        copy(argCopy, mmClearUserCart.callArgs)

        mmClearUserCart.mutex.RUnlock()

        return argCopy
}</span>

// MinimockClearUserCartDone returns true if the count of the ClearUserCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockClearUserCartDone() bool <span class="cov8" title="1">{
        if m.ClearUserCartMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.ClearUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.ClearUserCartMock.invocationsDone()</span>
}

// MinimockClearUserCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockClearUserCartInspect() <span class="cov0" title="0">{
        for _, e := range m.ClearUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CartRepositoryMock.ClearUserCart with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterClearUserCartCounter := mm_atomic.LoadUint64(&amp;m.afterClearUserCartCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ClearUserCartMock.defaultExpectation != nil &amp;&amp; afterClearUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ClearUserCartMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to CartRepositoryMock.ClearUserCart")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CartRepositoryMock.ClearUserCart with params: %#v", *m.ClearUserCartMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcClearUserCart != nil &amp;&amp; afterClearUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to CartRepositoryMock.ClearUserCart")
        }</span>

        <span class="cov0" title="0">if !m.ClearUserCartMock.invocationsDone() &amp;&amp; afterClearUserCartCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CartRepositoryMock.ClearUserCart but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ClearUserCartMock.expectedInvocations), afterClearUserCartCounter)
        }</span>
}

type mCartRepositoryMockDeleteItemFromUserCart struct {
        optional           bool
        mock               *CartRepositoryMock
        defaultExpectation *CartRepositoryMockDeleteItemFromUserCartExpectation
        expectations       []*CartRepositoryMockDeleteItemFromUserCartExpectation

        callArgs []*CartRepositoryMockDeleteItemFromUserCartParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// CartRepositoryMockDeleteItemFromUserCartExpectation specifies expectation struct of the cartRepository.DeleteItemFromUserCart
type CartRepositoryMockDeleteItemFromUserCartExpectation struct {
        mock      *CartRepositoryMock
        params    *CartRepositoryMockDeleteItemFromUserCartParams
        paramPtrs *CartRepositoryMockDeleteItemFromUserCartParamPtrs
        results   *CartRepositoryMockDeleteItemFromUserCartResults
        Counter   uint64
}

// CartRepositoryMockDeleteItemFromUserCartParams contains parameters of the cartRepository.DeleteItemFromUserCart
type CartRepositoryMockDeleteItemFromUserCartParams struct {
        ctx    context.Context
        userID int64
        skuID  int64
}

// CartRepositoryMockDeleteItemFromUserCartParamPtrs contains pointers to parameters of the cartRepository.DeleteItemFromUserCart
type CartRepositoryMockDeleteItemFromUserCartParamPtrs struct {
        ctx    *context.Context
        userID *int64
        skuID  *int64
}

// CartRepositoryMockDeleteItemFromUserCartResults contains results of the cartRepository.DeleteItemFromUserCart
type CartRepositoryMockDeleteItemFromUserCartResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Optional() *mCartRepositoryMockDeleteItemFromUserCart <span class="cov0" title="0">{
        mmDeleteItemFromUserCart.optional = true
        return mmDeleteItemFromUserCart
}</span>

// Expect sets up expected params for cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Expect(ctx context.Context, userID int64, skuID int64) *mCartRepositoryMockDeleteItemFromUserCart <span class="cov0" title="0">{
        if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.defaultExpectation = &amp;CartRepositoryMockDeleteItemFromUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmDeleteItemFromUserCart.defaultExpectation.params = &amp;CartRepositoryMockDeleteItemFromUserCartParams{ctx, userID, skuID}
        for _, e := range mmDeleteItemFromUserCart.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmDeleteItemFromUserCart.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmDeleteItemFromUserCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItemFromUserCart.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmDeleteItemFromUserCart</span>
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDeleteItemFromUserCart <span class="cov0" title="0">{
        if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.defaultExpectation = &amp;CartRepositoryMockDeleteItemFromUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockDeleteItemFromUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteItemFromUserCart.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmDeleteItemFromUserCart</span>
}

// ExpectUserIDParam2 sets up expected param userID for cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) ExpectUserIDParam2(userID int64) *mCartRepositoryMockDeleteItemFromUserCart <span class="cov0" title="0">{
        if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.defaultExpectation = &amp;CartRepositoryMockDeleteItemFromUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockDeleteItemFromUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteItemFromUserCart.defaultExpectation.paramPtrs.userID = &amp;userID

        return mmDeleteItemFromUserCart</span>
}

// ExpectSkuIDParam3 sets up expected param skuID for cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) ExpectSkuIDParam3(skuID int64) *mCartRepositoryMockDeleteItemFromUserCart <span class="cov0" title="0">{
        if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.defaultExpectation = &amp;CartRepositoryMockDeleteItemFromUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockDeleteItemFromUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteItemFromUserCart.defaultExpectation.paramPtrs.skuID = &amp;skuID

        return mmDeleteItemFromUserCart</span>
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Inspect(f func(ctx context.Context, userID int64, skuID int64)) *mCartRepositoryMockDeleteItemFromUserCart <span class="cov0" title="0">{
        if mmDeleteItemFromUserCart.mock.inspectFuncDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteItemFromUserCart")
        }</span>

        <span class="cov0" title="0">mmDeleteItemFromUserCart.mock.inspectFuncDeleteItemFromUserCart = f

        return mmDeleteItemFromUserCart</span>
}

// Return sets up results that will be returned by cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Return(err error) *CartRepositoryMock <span class="cov8" title="1">{
        if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmDeleteItemFromUserCart.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmDeleteItemFromUserCart.defaultExpectation = &amp;CartRepositoryMockDeleteItemFromUserCartExpectation{mock: mmDeleteItemFromUserCart.mock}
        }</span>
        <span class="cov8" title="1">mmDeleteItemFromUserCart.defaultExpectation.results = &amp;CartRepositoryMockDeleteItemFromUserCartResults{err}
        return mmDeleteItemFromUserCart.mock</span>
}

// Set uses given function f to mock the cartRepository.DeleteItemFromUserCart method
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Set(f func(ctx context.Context, userID int64, skuID int64) (err error)) *CartRepositoryMock <span class="cov0" title="0">{
        if mmDeleteItemFromUserCart.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("Default expectation is already set for the cartRepository.DeleteItemFromUserCart method")
        }</span>

        <span class="cov0" title="0">if len(mmDeleteItemFromUserCart.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("Some expectations are already set for the cartRepository.DeleteItemFromUserCart method")
        }</span>

        <span class="cov0" title="0">mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart = f
        return mmDeleteItemFromUserCart.mock</span>
}

// When sets expectation for the cartRepository.DeleteItemFromUserCart which will trigger the result defined by the following
// Then helper
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) When(ctx context.Context, userID int64, skuID int64) *CartRepositoryMockDeleteItemFromUserCartExpectation <span class="cov0" title="0">{
        if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CartRepositoryMockDeleteItemFromUserCartExpectation{
                mock:   mmDeleteItemFromUserCart.mock,
                params: &amp;CartRepositoryMockDeleteItemFromUserCartParams{ctx, userID, skuID},
        }
        mmDeleteItemFromUserCart.expectations = append(mmDeleteItemFromUserCart.expectations, expectation)
        return expectation</span>
}

// Then sets up cartRepository.DeleteItemFromUserCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteItemFromUserCartExpectation) Then(err error) *CartRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;CartRepositoryMockDeleteItemFromUserCartResults{err}
        return e.mock
}</span>

// Times sets number of times cartRepository.DeleteItemFromUserCart should be invoked
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Times(n uint64) *mCartRepositoryMockDeleteItemFromUserCart <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("Times of CartRepositoryMock.DeleteItemFromUserCart mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmDeleteItemFromUserCart.expectedInvocations, n)
        return mmDeleteItemFromUserCart</span>
}

func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmDeleteItemFromUserCart.expectations) == 0 &amp;&amp; mmDeleteItemFromUserCart.defaultExpectation == nil &amp;&amp; mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmDeleteItemFromUserCart.mock.afterDeleteItemFromUserCartCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmDeleteItemFromUserCart.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// DeleteItemFromUserCart implements service.cartRepository
func (mmDeleteItemFromUserCart *CartRepositoryMock) DeleteItemFromUserCart(ctx context.Context, userID int64, skuID int64) (err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmDeleteItemFromUserCart.beforeDeleteItemFromUserCartCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmDeleteItemFromUserCart.afterDeleteItemFromUserCartCounter, 1)

        if mmDeleteItemFromUserCart.inspectFuncDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.inspectFuncDeleteItemFromUserCart(ctx, userID, skuID)
        }</span>

        <span class="cov8" title="1">mm_params := CartRepositoryMockDeleteItemFromUserCartParams{ctx, userID, skuID}

        // Record call args
        mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.mutex.Lock()
        mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.callArgs = append(mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.callArgs, &amp;mm_params)
        mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.mutex.Unlock()

        for _, e := range mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation.Counter, 1)
                mm_want := mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation.params
                mm_want_ptrs := mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation.paramPtrs

                mm_got := CartRepositoryMockDeleteItemFromUserCartParams{ctx, userID, skuID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmDeleteItemFromUserCart.t.Errorf("CartRepositoryMock.DeleteItemFromUserCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.userID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) </span><span class="cov0" title="0">{
                                mmDeleteItemFromUserCart.t.Errorf("CartRepositoryMock.DeleteItemFromUserCart got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.skuID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) </span><span class="cov0" title="0">{
                                mmDeleteItemFromUserCart.t.Errorf("CartRepositoryMock.DeleteItemFromUserCart got unexpected parameter skuID, want: %#v, got: %#v%s\n", *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmDeleteItemFromUserCart.t.Errorf("CartRepositoryMock.DeleteItemFromUserCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmDeleteItemFromUserCart.t.Fatal("No results are set for the CartRepositoryMock.DeleteItemFromUserCart")
                }</span>
                <span class="cov8" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmDeleteItemFromUserCart.funcDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                return mmDeleteItemFromUserCart.funcDeleteItemFromUserCart(ctx, userID, skuID)
        }</span>
        <span class="cov0" title="0">mmDeleteItemFromUserCart.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteItemFromUserCart. %v %v %v", ctx, userID, skuID)
        return</span>
}

// DeleteItemFromUserCartAfterCounter returns a count of finished CartRepositoryMock.DeleteItemFromUserCart invocations
func (mmDeleteItemFromUserCart *CartRepositoryMock) DeleteItemFromUserCartAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteItemFromUserCart.afterDeleteItemFromUserCartCounter)
}</span>

// DeleteItemFromUserCartBeforeCounter returns a count of CartRepositoryMock.DeleteItemFromUserCart invocations
func (mmDeleteItemFromUserCart *CartRepositoryMock) DeleteItemFromUserCartBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteItemFromUserCart.beforeDeleteItemFromUserCartCounter)
}</span>

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteItemFromUserCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Calls() []*CartRepositoryMockDeleteItemFromUserCartParams <span class="cov0" title="0">{
        mmDeleteItemFromUserCart.mutex.RLock()

        argCopy := make([]*CartRepositoryMockDeleteItemFromUserCartParams, len(mmDeleteItemFromUserCart.callArgs))
        copy(argCopy, mmDeleteItemFromUserCart.callArgs)

        mmDeleteItemFromUserCart.mutex.RUnlock()

        return argCopy
}</span>

// MinimockDeleteItemFromUserCartDone returns true if the count of the DeleteItemFromUserCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteItemFromUserCartDone() bool <span class="cov8" title="1">{
        if m.DeleteItemFromUserCartMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.DeleteItemFromUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.DeleteItemFromUserCartMock.invocationsDone()</span>
}

// MinimockDeleteItemFromUserCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteItemFromUserCartInspect() <span class="cov0" title="0">{
        for _, e := range m.DeleteItemFromUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CartRepositoryMock.DeleteItemFromUserCart with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterDeleteItemFromUserCartCounter := mm_atomic.LoadUint64(&amp;m.afterDeleteItemFromUserCartCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.DeleteItemFromUserCartMock.defaultExpectation != nil &amp;&amp; afterDeleteItemFromUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.DeleteItemFromUserCartMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to CartRepositoryMock.DeleteItemFromUserCart")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CartRepositoryMock.DeleteItemFromUserCart with params: %#v", *m.DeleteItemFromUserCartMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcDeleteItemFromUserCart != nil &amp;&amp; afterDeleteItemFromUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to CartRepositoryMock.DeleteItemFromUserCart")
        }</span>

        <span class="cov0" title="0">if !m.DeleteItemFromUserCartMock.invocationsDone() &amp;&amp; afterDeleteItemFromUserCartCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteItemFromUserCart but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.DeleteItemFromUserCartMock.expectedInvocations), afterDeleteItemFromUserCartCounter)
        }</span>
}

type mCartRepositoryMockListUserCart struct {
        optional           bool
        mock               *CartRepositoryMock
        defaultExpectation *CartRepositoryMockListUserCartExpectation
        expectations       []*CartRepositoryMockListUserCartExpectation

        callArgs []*CartRepositoryMockListUserCartParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// CartRepositoryMockListUserCartExpectation specifies expectation struct of the cartRepository.ListUserCart
type CartRepositoryMockListUserCartExpectation struct {
        mock      *CartRepositoryMock
        params    *CartRepositoryMockListUserCartParams
        paramPtrs *CartRepositoryMockListUserCartParamPtrs
        results   *CartRepositoryMockListUserCartResults
        Counter   uint64
}

// CartRepositoryMockListUserCartParams contains parameters of the cartRepository.ListUserCart
type CartRepositoryMockListUserCartParams struct {
        ctx    context.Context
        userID int64
}

// CartRepositoryMockListUserCartParamPtrs contains pointers to parameters of the cartRepository.ListUserCart
type CartRepositoryMockListUserCartParamPtrs struct {
        ctx    *context.Context
        userID *int64
}

// CartRepositoryMockListUserCartResults contains results of the cartRepository.ListUserCart
type CartRepositoryMockListUserCartResults struct {
        ca1 []models.CartItem
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListUserCart *mCartRepositoryMockListUserCart) Optional() *mCartRepositoryMockListUserCart <span class="cov0" title="0">{
        mmListUserCart.optional = true
        return mmListUserCart
}</span>

// Expect sets up expected params for cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) Expect(ctx context.Context, userID int64) *mCartRepositoryMockListUserCart <span class="cov0" title="0">{
        if mmListUserCart.mock.funcListUserCart != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListUserCart.defaultExpectation = &amp;CartRepositoryMockListUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmListUserCart.defaultExpectation.params = &amp;CartRepositoryMockListUserCartParams{ctx, userID}
        for _, e := range mmListUserCart.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmListUserCart.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmListUserCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListUserCart.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmListUserCart</span>
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockListUserCart <span class="cov0" title="0">{
        if mmListUserCart.mock.funcListUserCart != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListUserCart.defaultExpectation = &amp;CartRepositoryMockListUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmListUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockListUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmListUserCart.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmListUserCart</span>
}

// ExpectUserIDParam2 sets up expected param userID for cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) ExpectUserIDParam2(userID int64) *mCartRepositoryMockListUserCart <span class="cov0" title="0">{
        if mmListUserCart.mock.funcListUserCart != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListUserCart.defaultExpectation = &amp;CartRepositoryMockListUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmListUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockListUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmListUserCart.defaultExpectation.paramPtrs.userID = &amp;userID

        return mmListUserCart</span>
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) Inspect(f func(ctx context.Context, userID int64)) *mCartRepositoryMockListUserCart <span class="cov0" title="0">{
        if mmListUserCart.mock.inspectFuncListUserCart != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ListUserCart")
        }</span>

        <span class="cov0" title="0">mmListUserCart.mock.inspectFuncListUserCart = f

        return mmListUserCart</span>
}

// Return sets up results that will be returned by cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) Return(ca1 []models.CartItem, err error) *CartRepositoryMock <span class="cov8" title="1">{
        if mmListUserCart.mock.funcListUserCart != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmListUserCart.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmListUserCart.defaultExpectation = &amp;CartRepositoryMockListUserCartExpectation{mock: mmListUserCart.mock}
        }</span>
        <span class="cov8" title="1">mmListUserCart.defaultExpectation.results = &amp;CartRepositoryMockListUserCartResults{ca1, err}
        return mmListUserCart.mock</span>
}

// Set uses given function f to mock the cartRepository.ListUserCart method
func (mmListUserCart *mCartRepositoryMockListUserCart) Set(f func(ctx context.Context, userID int64) (ca1 []models.CartItem, err error)) *CartRepositoryMock <span class="cov0" title="0">{
        if mmListUserCart.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("Default expectation is already set for the cartRepository.ListUserCart method")
        }</span>

        <span class="cov0" title="0">if len(mmListUserCart.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("Some expectations are already set for the cartRepository.ListUserCart method")
        }</span>

        <span class="cov0" title="0">mmListUserCart.mock.funcListUserCart = f
        return mmListUserCart.mock</span>
}

// When sets expectation for the cartRepository.ListUserCart which will trigger the result defined by the following
// Then helper
func (mmListUserCart *mCartRepositoryMockListUserCart) When(ctx context.Context, userID int64) *CartRepositoryMockListUserCartExpectation <span class="cov0" title="0">{
        if mmListUserCart.mock.funcListUserCart != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CartRepositoryMockListUserCartExpectation{
                mock:   mmListUserCart.mock,
                params: &amp;CartRepositoryMockListUserCartParams{ctx, userID},
        }
        mmListUserCart.expectations = append(mmListUserCart.expectations, expectation)
        return expectation</span>
}

// Then sets up cartRepository.ListUserCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockListUserCartExpectation) Then(ca1 []models.CartItem, err error) *CartRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;CartRepositoryMockListUserCartResults{ca1, err}
        return e.mock
}</span>

// Times sets number of times cartRepository.ListUserCart should be invoked
func (mmListUserCart *mCartRepositoryMockListUserCart) Times(n uint64) *mCartRepositoryMockListUserCart <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("Times of CartRepositoryMock.ListUserCart mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmListUserCart.expectedInvocations, n)
        return mmListUserCart</span>
}

func (mmListUserCart *mCartRepositoryMockListUserCart) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmListUserCart.expectations) == 0 &amp;&amp; mmListUserCart.defaultExpectation == nil &amp;&amp; mmListUserCart.mock.funcListUserCart == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmListUserCart.mock.afterListUserCartCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmListUserCart.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ListUserCart implements service.cartRepository
func (mmListUserCart *CartRepositoryMock) ListUserCart(ctx context.Context, userID int64) (ca1 []models.CartItem, err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmListUserCart.beforeListUserCartCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmListUserCart.afterListUserCartCounter, 1)

        if mmListUserCart.inspectFuncListUserCart != nil </span><span class="cov0" title="0">{
                mmListUserCart.inspectFuncListUserCart(ctx, userID)
        }</span>

        <span class="cov8" title="1">mm_params := CartRepositoryMockListUserCartParams{ctx, userID}

        // Record call args
        mmListUserCart.ListUserCartMock.mutex.Lock()
        mmListUserCart.ListUserCartMock.callArgs = append(mmListUserCart.ListUserCartMock.callArgs, &amp;mm_params)
        mmListUserCart.ListUserCartMock.mutex.Unlock()

        for _, e := range mmListUserCart.ListUserCartMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.ca1, e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmListUserCart.ListUserCartMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmListUserCart.ListUserCartMock.defaultExpectation.Counter, 1)
                mm_want := mmListUserCart.ListUserCartMock.defaultExpectation.params
                mm_want_ptrs := mmListUserCart.ListUserCartMock.defaultExpectation.paramPtrs

                mm_got := CartRepositoryMockListUserCartParams{ctx, userID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmListUserCart.t.Errorf("CartRepositoryMock.ListUserCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.userID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) </span><span class="cov0" title="0">{
                                mmListUserCart.t.Errorf("CartRepositoryMock.ListUserCart got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmListUserCart.t.Errorf("CartRepositoryMock.ListUserCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmListUserCart.ListUserCartMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmListUserCart.t.Fatal("No results are set for the CartRepositoryMock.ListUserCart")
                }</span>
                <span class="cov8" title="1">return (*mm_results).ca1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmListUserCart.funcListUserCart != nil </span><span class="cov0" title="0">{
                return mmListUserCart.funcListUserCart(ctx, userID)
        }</span>
        <span class="cov0" title="0">mmListUserCart.t.Fatalf("Unexpected call to CartRepositoryMock.ListUserCart. %v %v", ctx, userID)
        return</span>
}

// ListUserCartAfterCounter returns a count of finished CartRepositoryMock.ListUserCart invocations
func (mmListUserCart *CartRepositoryMock) ListUserCartAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmListUserCart.afterListUserCartCounter)
}</span>

// ListUserCartBeforeCounter returns a count of CartRepositoryMock.ListUserCart invocations
func (mmListUserCart *CartRepositoryMock) ListUserCartBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmListUserCart.beforeListUserCartCounter)
}</span>

// Calls returns a list of arguments used in each call to CartRepositoryMock.ListUserCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListUserCart *mCartRepositoryMockListUserCart) Calls() []*CartRepositoryMockListUserCartParams <span class="cov0" title="0">{
        mmListUserCart.mutex.RLock()

        argCopy := make([]*CartRepositoryMockListUserCartParams, len(mmListUserCart.callArgs))
        copy(argCopy, mmListUserCart.callArgs)

        mmListUserCart.mutex.RUnlock()

        return argCopy
}</span>

// MinimockListUserCartDone returns true if the count of the ListUserCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockListUserCartDone() bool <span class="cov8" title="1">{
        if m.ListUserCartMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.ListUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.ListUserCartMock.invocationsDone()</span>
}

// MinimockListUserCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockListUserCartInspect() <span class="cov0" title="0">{
        for _, e := range m.ListUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CartRepositoryMock.ListUserCart with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterListUserCartCounter := mm_atomic.LoadUint64(&amp;m.afterListUserCartCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ListUserCartMock.defaultExpectation != nil &amp;&amp; afterListUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ListUserCartMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to CartRepositoryMock.ListUserCart")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CartRepositoryMock.ListUserCart with params: %#v", *m.ListUserCartMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcListUserCart != nil &amp;&amp; afterListUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to CartRepositoryMock.ListUserCart")
        }</span>

        <span class="cov0" title="0">if !m.ListUserCartMock.invocationsDone() &amp;&amp; afterListUserCartCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CartRepositoryMock.ListUserCart but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ListUserCartMock.expectedInvocations), afterListUserCartCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() <span class="cov8" title="1">{
        m.finishOnce.Do(func() </span><span class="cov8" title="1">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockAddItemToUserCartInspect()

                        m.MinimockClearUserCartInspect()

                        m.MinimockDeleteItemFromUserCartInspect()

                        m.MinimockListUserCartInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *CartRepositoryMock) minimockDone() bool <span class="cov8" title="1">{
        done := true
        return done &amp;&amp;
                m.MinimockAddItemToUserCartDone() &amp;&amp;
                m.MinimockClearUserCartDone() &amp;&amp;
                m.MinimockDeleteItemFromUserCartDone() &amp;&amp;
                m.MinimockListUserCartDone()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/cart/internal/service.productClient -o product_client_mock.go -n ProductClientMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "route256/cart/pkg/product"

        "github.com/gojuno/minimock/v3"
)

// ProductClientMock implements service.productClient
type ProductClientMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcGetProduct          func(ctx context.Context, skuID uint32) (pp1 *product.Product, err error)
        inspectFuncGetProduct   func(ctx context.Context, skuID uint32)
        afterGetProductCounter  uint64
        beforeGetProductCounter uint64
        GetProductMock          mProductClientMockGetProduct
}

// NewProductClientMock returns a mock for service.productClient
func NewProductClientMock(t minimock.Tester) *ProductClientMock <span class="cov8" title="1">{
        m := &amp;ProductClientMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="1">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="1">m.GetProductMock = mProductClientMockGetProduct{mock: m}
        m.GetProductMock.callArgs = []*ProductClientMockGetProductParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mProductClientMockGetProduct struct {
        optional           bool
        mock               *ProductClientMock
        defaultExpectation *ProductClientMockGetProductExpectation
        expectations       []*ProductClientMockGetProductExpectation

        callArgs []*ProductClientMockGetProductParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// ProductClientMockGetProductExpectation specifies expectation struct of the productClient.GetProduct
type ProductClientMockGetProductExpectation struct {
        mock      *ProductClientMock
        params    *ProductClientMockGetProductParams
        paramPtrs *ProductClientMockGetProductParamPtrs
        results   *ProductClientMockGetProductResults
        Counter   uint64
}

// ProductClientMockGetProductParams contains parameters of the productClient.GetProduct
type ProductClientMockGetProductParams struct {
        ctx   context.Context
        skuID uint32
}

// ProductClientMockGetProductParamPtrs contains pointers to parameters of the productClient.GetProduct
type ProductClientMockGetProductParamPtrs struct {
        ctx   *context.Context
        skuID *uint32
}

// ProductClientMockGetProductResults contains results of the productClient.GetProduct
type ProductClientMockGetProductResults struct {
        pp1 *product.Product
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetProduct *mProductClientMockGetProduct) Optional() *mProductClientMockGetProduct <span class="cov0" title="0">{
        mmGetProduct.optional = true
        return mmGetProduct
}</span>

// Expect sets up expected params for productClient.GetProduct
func (mmGetProduct *mProductClientMockGetProduct) Expect(ctx context.Context, skuID uint32) *mProductClientMockGetProduct <span class="cov0" title="0">{
        if mmGetProduct.mock.funcGetProduct != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetProduct.defaultExpectation = &amp;ProductClientMockGetProductExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetProduct.defaultExpectation.params = &amp;ProductClientMockGetProductParams{ctx, skuID}
        for _, e := range mmGetProduct.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetProduct.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProduct.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetProduct</span>
}

// ExpectCtxParam1 sets up expected param ctx for productClient.GetProduct
func (mmGetProduct *mProductClientMockGetProduct) ExpectCtxParam1(ctx context.Context) *mProductClientMockGetProduct <span class="cov0" title="0">{
        if mmGetProduct.mock.funcGetProduct != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetProduct.defaultExpectation = &amp;ProductClientMockGetProductExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetProduct.defaultExpectation.paramPtrs = &amp;ProductClientMockGetProductParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetProduct.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmGetProduct</span>
}

// ExpectSkuIDParam2 sets up expected param skuID for productClient.GetProduct
func (mmGetProduct *mProductClientMockGetProduct) ExpectSkuIDParam2(skuID uint32) *mProductClientMockGetProduct <span class="cov0" title="0">{
        if mmGetProduct.mock.funcGetProduct != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetProduct.defaultExpectation = &amp;ProductClientMockGetProductExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetProduct.defaultExpectation.paramPtrs = &amp;ProductClientMockGetProductParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetProduct.defaultExpectation.paramPtrs.skuID = &amp;skuID

        return mmGetProduct</span>
}

// Inspect accepts an inspector function that has same arguments as the productClient.GetProduct
func (mmGetProduct *mProductClientMockGetProduct) Inspect(f func(ctx context.Context, skuID uint32)) *mProductClientMockGetProduct <span class="cov0" title="0">{
        if mmGetProduct.mock.inspectFuncGetProduct != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("Inspect function is already set for ProductClientMock.GetProduct")
        }</span>

        <span class="cov0" title="0">mmGetProduct.mock.inspectFuncGetProduct = f

        return mmGetProduct</span>
}

// Return sets up results that will be returned by productClient.GetProduct
func (mmGetProduct *mProductClientMockGetProduct) Return(pp1 *product.Product, err error) *ProductClientMock <span class="cov8" title="1">{
        if mmGetProduct.mock.funcGetProduct != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmGetProduct.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmGetProduct.defaultExpectation = &amp;ProductClientMockGetProductExpectation{mock: mmGetProduct.mock}
        }</span>
        <span class="cov8" title="1">mmGetProduct.defaultExpectation.results = &amp;ProductClientMockGetProductResults{pp1, err}
        return mmGetProduct.mock</span>
}

// Set uses given function f to mock the productClient.GetProduct method
func (mmGetProduct *mProductClientMockGetProduct) Set(f func(ctx context.Context, skuID uint32) (pp1 *product.Product, err error)) *ProductClientMock <span class="cov8" title="1">{
        if mmGetProduct.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("Default expectation is already set for the productClient.GetProduct method")
        }</span>

        <span class="cov8" title="1">if len(mmGetProduct.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("Some expectations are already set for the productClient.GetProduct method")
        }</span>

        <span class="cov8" title="1">mmGetProduct.mock.funcGetProduct = f
        return mmGetProduct.mock</span>
}

// When sets expectation for the productClient.GetProduct which will trigger the result defined by the following
// Then helper
func (mmGetProduct *mProductClientMockGetProduct) When(ctx context.Context, skuID uint32) *ProductClientMockGetProductExpectation <span class="cov0" title="0">{
        if mmGetProduct.mock.funcGetProduct != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;ProductClientMockGetProductExpectation{
                mock:   mmGetProduct.mock,
                params: &amp;ProductClientMockGetProductParams{ctx, skuID},
        }
        mmGetProduct.expectations = append(mmGetProduct.expectations, expectation)
        return expectation</span>
}

// Then sets up productClient.GetProduct return parameters for the expectation previously defined by the When method
func (e *ProductClientMockGetProductExpectation) Then(pp1 *product.Product, err error) *ProductClientMock <span class="cov0" title="0">{
        e.results = &amp;ProductClientMockGetProductResults{pp1, err}
        return e.mock
}</span>

// Times sets number of times productClient.GetProduct should be invoked
func (mmGetProduct *mProductClientMockGetProduct) Times(n uint64) *mProductClientMockGetProduct <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("Times of ProductClientMock.GetProduct mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetProduct.expectedInvocations, n)
        return mmGetProduct</span>
}

func (mmGetProduct *mProductClientMockGetProduct) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmGetProduct.expectations) == 0 &amp;&amp; mmGetProduct.defaultExpectation == nil &amp;&amp; mmGetProduct.mock.funcGetProduct == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetProduct.mock.afterGetProductCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetProduct.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetProduct implements service.productClient
func (mmGetProduct *ProductClientMock) GetProduct(ctx context.Context, skuID uint32) (pp1 *product.Product, err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmGetProduct.beforeGetProductCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetProduct.afterGetProductCounter, 1)

        if mmGetProduct.inspectFuncGetProduct != nil </span><span class="cov0" title="0">{
                mmGetProduct.inspectFuncGetProduct(ctx, skuID)
        }</span>

        <span class="cov8" title="1">mm_params := ProductClientMockGetProductParams{ctx, skuID}

        // Record call args
        mmGetProduct.GetProductMock.mutex.Lock()
        mmGetProduct.GetProductMock.callArgs = append(mmGetProduct.GetProductMock.callArgs, &amp;mm_params)
        mmGetProduct.GetProductMock.mutex.Unlock()

        for _, e := range mmGetProduct.GetProductMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.pp1, e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmGetProduct.GetProductMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmGetProduct.GetProductMock.defaultExpectation.Counter, 1)
                mm_want := mmGetProduct.GetProductMock.defaultExpectation.params
                mm_want_ptrs := mmGetProduct.GetProductMock.defaultExpectation.paramPtrs

                mm_got := ProductClientMockGetProductParams{ctx, skuID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetProduct.t.Errorf("ProductClientMock.GetProduct got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.skuID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) </span><span class="cov0" title="0">{
                                mmGetProduct.t.Errorf("ProductClientMock.GetProduct got unexpected parameter skuID, want: %#v, got: %#v%s\n", *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetProduct.t.Errorf("ProductClientMock.GetProduct got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmGetProduct.GetProductMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetProduct.t.Fatal("No results are set for the ProductClientMock.GetProduct")
                }</span>
                <span class="cov8" title="1">return (*mm_results).pp1, (*mm_results).err</span>
        }
        <span class="cov8" title="1">if mmGetProduct.funcGetProduct != nil </span><span class="cov8" title="1">{
                return mmGetProduct.funcGetProduct(ctx, skuID)
        }</span>
        <span class="cov0" title="0">mmGetProduct.t.Fatalf("Unexpected call to ProductClientMock.GetProduct. %v %v", ctx, skuID)
        return</span>
}

// GetProductAfterCounter returns a count of finished ProductClientMock.GetProduct invocations
func (mmGetProduct *ProductClientMock) GetProductAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetProduct.afterGetProductCounter)
}</span>

// GetProductBeforeCounter returns a count of ProductClientMock.GetProduct invocations
func (mmGetProduct *ProductClientMock) GetProductBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetProduct.beforeGetProductCounter)
}</span>

// Calls returns a list of arguments used in each call to ProductClientMock.GetProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProduct *mProductClientMockGetProduct) Calls() []*ProductClientMockGetProductParams <span class="cov0" title="0">{
        mmGetProduct.mutex.RLock()

        argCopy := make([]*ProductClientMockGetProductParams, len(mmGetProduct.callArgs))
        copy(argCopy, mmGetProduct.callArgs)

        mmGetProduct.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetProductDone returns true if the count of the GetProduct invocations corresponds
// the number of defined expectations
func (m *ProductClientMock) MinimockGetProductDone() bool <span class="cov8" title="1">{
        if m.GetProductMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.GetProductMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.GetProductMock.invocationsDone()</span>
}

// MinimockGetProductInspect logs each unmet expectation
func (m *ProductClientMock) MinimockGetProductInspect() <span class="cov0" title="0">{
        for _, e := range m.GetProductMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ProductClientMock.GetProduct with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetProductCounter := mm_atomic.LoadUint64(&amp;m.afterGetProductCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetProductMock.defaultExpectation != nil &amp;&amp; afterGetProductCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetProductMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ProductClientMock.GetProduct")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to ProductClientMock.GetProduct with params: %#v", *m.GetProductMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetProduct != nil &amp;&amp; afterGetProductCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to ProductClientMock.GetProduct")
        }</span>

        <span class="cov0" title="0">if !m.GetProductMock.invocationsDone() &amp;&amp; afterGetProductCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ProductClientMock.GetProduct but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetProductMock.expectedInvocations), afterGetProductCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProductClientMock) MinimockFinish() <span class="cov8" title="1">{
        m.finishOnce.Do(func() </span><span class="cov8" title="1">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockGetProductInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProductClientMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *ProductClientMock) minimockDone() bool <span class="cov8" title="1">{
        done := true
        return done &amp;&amp;
                m.MinimockGetProductDone()
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package service

import (
        "context"
        "fmt"
        "sort"

        "route256/cart/internal/models"
        "route256/cart/pkg/product"
)

//go:generate minimock -i cartRepository -o ./mocks/ -s _mock.go
//go:generate minimock -i productClient -o ./mocks/ -s _mock.go
type cartRepository interface {
        AddItemToUserCart(ctx context.Context, cart models.CartRequest) error
        DeleteItemFromUserCart(ctx context.Context, userID, skuID int64) error
        ClearUserCart(ctx context.Context, userID int64) error
        ListUserCart(ctx context.Context, userID int64) ([]models.CartItem, error)
}

type productClient interface {
        GetProduct(ctx context.Context, skuID uint32) (*product.Product, error)
}

type Service struct {
        repo          cartRepository
        productClient productClient
}

func NewService(repo cartRepository, productClient productClient) *Service <span class="cov8" title="1">{
        return &amp;Service{repo: repo, productClient: productClient}
}</span>

func (s *Service) AddItemToUserCart(ctx context.Context, cart models.CartRequest) error <span class="cov8" title="1">{
        checkProduct, err := s.productClient.GetProduct(ctx, uint32(cart.SkuID))
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get product: %w", err)
        }</span>

        <span class="cov8" title="1">if checkProduct == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("product not found")
        }</span>

        <span class="cov8" title="1">return s.repo.AddItemToUserCart(ctx, cart)</span>
}

func (s *Service) DeleteItemFromUserCart(ctx context.Context, userID, skuID int64) error <span class="cov8" title="1">{
        return s.repo.DeleteItemFromUserCart(ctx, userID, skuID)
}</span>

func (s *Service) ClearUserCart(ctx context.Context, userID int64) error <span class="cov8" title="1">{
        return s.repo.ClearUserCart(ctx, userID)
}</span>

func (s *Service) ListUserCart(ctx context.Context, userID int64) ([]models.CartItem, uint32, error) <span class="cov8" title="1">{
        items, err := s.repo.ListUserCart(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, 0, fmt.Errorf("failed to list cart: %w", err)
        }</span>

        <span class="cov8" title="1">cartItems := make([]models.CartItem, 0, len(items))
        totalPrice := uint32(0)

        for _, item := range items </span><span class="cov8" title="1">{
                p, err := s.productClient.GetProduct(ctx, uint32(item.SkuID))
                if err != nil </span><span class="cov8" title="1">{
                        return nil, 0, fmt.Errorf("failed to get p: %w", err)
                }</span>

                <span class="cov8" title="1">if p == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">cartItems = append(cartItems, models.CartItem{
                        SkuID: item.SkuID,
                        Name:  p.Name,
                        Count: item.Count,
                        Price: p.Price,
                })

                totalPrice += p.Price * uint32(item.Count)</span>
        }

        <span class="cov8" title="1">sort.Slice(cartItems, func(i, j int) bool </span><span class="cov8" title="1">{
                return cartItems[i].SkuID &lt; cartItems[j].SkuID
        }</span>)

        <span class="cov8" title="1">return cartItems, totalPrice, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package product

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "time"
)

type Client struct {
        baseURL string
        token   string
        client  *http.Client
}

func NewClient(baseURL, token string, timeout time.Duration) *Client <span class="cov8" title="1">{
        return &amp;Client{
                baseURL: baseURL,
                token:   token,
                client: &amp;http.Client{
                        Timeout: timeout,
                },
        }
}</span>

type Product struct {
        Name  string `json:"name"`
        Price uint32 `json:"price"`
}

type Response struct {
        Product
        Message string `json:"message"`
}

type ProductRequest struct {
        Token string `json:"token"`
        SkuID uint32 `json:"sku"`
}

func (c *Client) GetProduct(ctx context.Context, skuID uint32) (*Product, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/get_product", c.baseURL)

        requestBody, err := json.Marshal(ProductRequest{
                Token: c.token,
                SkuID: skuID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(requestBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close() //nolint:errcheck

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get product: %s", resp.Status)
        }</span>

        <span class="cov8" title="1">var response Response
        if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if response.Message == "sku not found" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("product not found")
        }</span>

        <span class="cov8" title="1">return &amp;response.Product, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handler

import (
        "net/http"
        "net/http/httptest"
        "time"

        "route256/cart/cmd/config"
        "route256/cart/internal/handler"
        "route256/cart/internal/repository"
        "route256/cart/internal/service"
        "route256/cart/pkg/product"

        "github.com/joho/godotenv"
        "github.com/stretchr/testify/suite"
)

type TestSuite struct {
        suite.Suite
        server  *httptest.Server
        repo    *repository.Repository
        service *service.Service
        handler *handler.Handler
}

func (suite *TestSuite) SetupSuite() <span class="cov8" title="1">{
        err := godotenv.Load("../../.env")
        if err != nil </span><span class="cov0" title="0">{
                suite.T().Fatalf("Error loading .env file: %v", err)
        }</span>

        <span class="cov8" title="1">cfg, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                suite.T().Fatalf("Failed to parse config: %v", err)
        }</span>

        <span class="cov8" title="1">productClientTimeout, err := time.ParseDuration(cfg.ProductClient.Timeout + "s")
        if err != nil </span><span class="cov0" title="0">{
                suite.T().Fatalf("Failed to parse product client timeout: %v", err)
        }</span>

        <span class="cov8" title="1">productClient := product.NewClient(cfg.ProductClient.Host, cfg.ProductClient.Token, productClientTimeout)
        repo := repository.NewRepository()
        svc := service.NewService(repo, productClient)
        handlers := handler.NewHandler(svc)

        mux := http.NewServeMux()
        handlers.RegisterRoutes(mux)

        suite.repo = repo
        suite.service = svc
        suite.handler = handlers

        server := httptest.NewServer(mux)

        suite.server = server</span>
}

func (suite *TestSuite) TearDownSuite() <span class="cov8" title="1">{
        suite.server.Close()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
