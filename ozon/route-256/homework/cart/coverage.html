
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">route256/cart/cmd/config/config.go (75.0%)</option>
				
				<option value="file1">route256/cart/cmd/main.go (0.0%)</option>
				
				<option value="file2">route256/cart/internal/handler/handler.go (33.0%)</option>
				
				<option value="file3">route256/cart/internal/handler/middleware.go (0.0%)</option>
				
				<option value="file4">route256/cart/internal/models/models.go (0.0%)</option>
				
				<option value="file5">route256/cart/internal/repository/repository.go (100.0%)</option>
				
				<option value="file6">route256/cart/internal/service/mocks/cart_repository_mock.go (26.7%)</option>
				
				<option value="file7">route256/cart/internal/service/mocks/loms_client_mock.go (15.1%)</option>
				
				<option value="file8">route256/cart/internal/service/mocks/product_client_mock.go (34.0%)</option>
				
				<option value="file9">route256/cart/internal/service/service.go (65.3%)</option>
				
				<option value="file10">route256/cart/pkg/errgroup/errgroup.go (100.0%)</option>
				
				<option value="file11">route256/cart/pkg/loms/config.go (0.0%)</option>
				
				<option value="file12">route256/cart/pkg/loms/loms.go (0.0%)</option>
				
				<option value="file13">route256/cart/pkg/product/product.go (68.0%)</option>
				
				<option value="file14">route256/cart/proto/loms.pb.go (4.3%)</option>
				
				<option value="file15">route256/cart/proto/loms_grpc.pb.go (0.0%)</option>
				
				<option value="file16">route256/cart/tests/handler/setup.go (86.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "github.com/caarlos0/env/v11"
)

type ServerConfig struct {
        Port string `env:"PORT,required"`
}

type ProductClient struct {
        Host    string `env:"PRODUCT_HOST,required"`
        Token   string `env:"PRODUCT_TOKEN,required"`
        Timeout string `env:"PRODUCT_TIMEOUT,required"`
        Rps     int    `env:"PRODUCT_RPS,required"`
}

type LomsClient struct {
        Host string `env:"LOMS_HOST,required"`
}

type Config struct {
        ServerConfig  ServerConfig
        ProductClient ProductClient
        LomsClient    LomsClient
}

func NewConfig() (Config, error) <span class="cov8" title="1">{
        cfg := Config{}

        if err := env.Parse(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return cfg, err
        }</span>

        <span class="cov8" title="1">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "errors"
        "log"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "time"

        "route256/cart/cmd/config"
        "route256/cart/internal/handler"
        "route256/cart/internal/repository"
        "route256/cart/internal/service"
        "route256/cart/pkg/loms"
        "route256/cart/pkg/product"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to parse config: %s", err)
        }</span>

        <span class="cov0" title="0">router := http.NewServeMux()

        productClient, err := product.NewClient(cfg.ProductClient)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to parse product client timeout: %s", err)
        }</span>

        <span class="cov0" title="0">lomsClient := loms.NewClient(cfg.LomsClient.Host)
        err = lomsClient.Run()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to start loms client: %s", err)
        }</span>

        <span class="cov0" title="0">repo := repository.NewRepository()
        serv := service.NewService(repo, productClient, lomsClient)
        hand := handler.NewHandler(serv)
        hand.RegisterRoutes(router)
        loggedMux := handler.LoggingMiddleware(router)

        server := &amp;http.Server{
                Addr:         ":" + cfg.ServerConfig.Port,
                Handler:      loggedMux,
                ReadTimeout:  10 * time.Second,
                WriteTimeout: 10 * time.Second,
                IdleTimeout:  15 * time.Second,
        }

        stop := make(chan os.Signal, 1)
        signal.Notify(stop, os.Interrupt)

        go func() </span><span class="cov0" title="0">{
                slog.Info("Starting server", slog.String("port", cfg.ServerConfig.Port))
                if err := server.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        slog.Error("Failed to start server", slog.String("error", err.Error()))
                }</span>
        }()

        <span class="cov0" title="0">&lt;-stop

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                slog.Error("Server forced to shutdown", slog.String("error", err.Error()))
        }</span>

        <span class="cov0" title="0">slog.Info("Server exiting")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handler

import (
        "context"
        "encoding/json"
        "net/http"
        "strconv"

        "route256/cart/internal/models"

        "github.com/go-playground/validator/v10"
)

type cartService interface {
        AddItemToUserCart(ctx context.Context, cart models.CartRequest) error
        DeleteItemFromUserCart(ctx context.Context, userID, skuID int64) error
        ClearUserCart(ctx context.Context, userID int64) error
        ListUserCart(ctx context.Context, userID int64) ([]models.CartItem, uint32, error)
        CreateOrder(ctx context.Context, userID int64) (int64, error)
}

type Handler struct {
        service  cartService
        validate *validator.Validate
}

func NewHandler(service cartService) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                service:  service,
                validate: validator.New(),
        }
}</span>

func (h *Handler) RegisterRoutes(mux *http.ServeMux) <span class="cov8" title="1">{
        mux.HandleFunc("POST /user/{userID}/cart/{skuID}", h.AddItemToUserCart)
        mux.HandleFunc("POST /cart/checkout", h.CreateOrder)
        mux.HandleFunc("DELETE /user/{userID}/cart/{skuID}", h.DeleteItemFromUserCart)
        mux.HandleFunc("DELETE /user/{userID}/cart", h.ClearUserCart)
        mux.HandleFunc("GET /user/{userID}/cart", h.ListUserCart)
}</span>

func (h *Handler) extractUserID(w http.ResponseWriter, r *http.Request) (int64, bool) <span class="cov8" title="1">{
        userID, err := strconv.ParseInt(r.PathValue("userID"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid user ID", http.StatusBadRequest)
                return 0, false
        }</span>

        <span class="cov8" title="1">return userID, true</span>
}

func (h *Handler) extractPathParams(w http.ResponseWriter, r *http.Request) (int64, int64, bool) <span class="cov8" title="1">{
        userID, err := strconv.ParseInt(r.PathValue("userID"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid user ID", http.StatusBadRequest)
                return 0, 0, false
        }</span>

        <span class="cov8" title="1">skuID, err := strconv.ParseInt(r.PathValue("skuID"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid SKU ID", http.StatusBadRequest)
                return 0, 0, false
        }</span>

        <span class="cov8" title="1">return userID, skuID, true</span>
}

func (h *Handler) AddItemToUserCart(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID, skuID, ok := h.extractPathParams(w, r)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">req := models.CartRequest{
                UserID: userID,
                SkuID:  skuID,
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.validate.Struct(req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.AddItemToUserCart(r.Context(), req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
}

func (h *Handler) DeleteItemFromUserCart(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, skuID, ok := h.extractPathParams(w, r)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">req := models.CartRequest{
                UserID: userID,
                SkuID:  skuID,
        }

        if err := h.validate.StructPartial(req, "UserID", "SkuID"); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.service.DeleteItemFromUserCart(r.Context(), req.UserID, req.SkuID); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *Handler) ClearUserCart(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID, ok := h.extractUserID(w, r)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">req := models.CartRequest{
                UserID: userID,
        }

        if err := h.validate.StructPartial(req, "UserID"); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.ClearUserCart(r.Context(), req.UserID); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *Handler) ListUserCart(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, ok := h.extractUserID(w, r)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">req := models.CartRequest{
                UserID: userID,
        }

        if err := h.validate.StructPartial(req, "UserID"); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">items, totalPrice, err := h.service.ListUserCart(r.Context(), req.UserID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if len(items) == 0 </span><span class="cov0" title="0">{
                http.Error(w, "cart not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">response := struct {
                Items      []models.CartItem `json:"items"`
                TotalPrice uint32            `json:"total_price"`
        }{
                Items:      items,
                TotalPrice: totalPrice,
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "failed to encode response", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}

func (h *Handler) CreateOrder(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        req := models.CartRequest{}

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.validate.StructPartial(req, "UserID"); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">orderID, err := h.service.CreateOrder(r.Context(), req.UserID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := struct {
                OrderID int64 `json:"order_id"`
        }{
                OrderID: orderID,
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "failed to encode response", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "log/slog"
        "net/http"
)

type statusRecorder struct {
        http.ResponseWriter
        status      int
        wroteHeader bool
}

func (rec *statusRecorder) WriteHeader(status int) <span class="cov0" title="0">{
        if !rec.wroteHeader </span><span class="cov0" title="0">{
                rec.status = status
                rec.ResponseWriter.WriteHeader(status)
                rec.wroteHeader = true
        }</span>
}

func (rec *statusRecorder) Write(b []byte) (int, error) <span class="cov0" title="0">{
        if !rec.wroteHeader </span><span class="cov0" title="0">{
                rec.WriteHeader(http.StatusOK)
        }</span>
        <span class="cov0" title="0">return rec.ResponseWriter.Write(b)</span>
}

func LoggingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                rec := &amp;statusRecorder{ResponseWriter: w}

                defer func() </span><span class="cov0" title="0">{
                        if rec.status &gt;= 400 </span><span class="cov0" title="0">{
                                slog.Error("HTTP request failed", "method", r.Method, "path", r.URL.Path, "status", rec.status)
                        }</span>
                }()

                <span class="cov0" title="0">next.ServeHTTP(rec, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "route256/cart/pkg/loms"
)

type CartItem struct {
        SkuID int64
        Name  string
        Count uint16
        Price uint32
}

type CartRequest struct {
        UserID int64  `json:"user_id" validate:"required,gt=0"`
        SkuID  int64  `json:"sku_id" validate:"required,gt=0"`
        Count  uint16 `json:"count" validate:"required,gt=0"`
}

func CartItemToCartRequest(ci CartItem) CartRequest <span class="cov0" title="0">{
        return CartRequest{
                SkuID: ci.SkuID,
                Count: ci.Count,
        }
}</span>

func CartRequestToCartOrder(cr []CartRequest) []loms.OrderItem <span class="cov0" title="0">{
        items := make([]loms.OrderItem, 0, len(cr))

        for _, item := range cr </span><span class="cov0" title="0">{
                items = append(items, loms.OrderItem{
                        SkuID:    uint64(item.SkuID),
                        Quantity: uint32(item.Count),
                })
        }</span>

        <span class="cov0" title="0">return items</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package repository

import (
        "context"
        "sync"

        "route256/cart/internal/models"
)

type Repository struct {
        carts map[int64]map[int64]uint16 // userID -&gt; skuID -&gt; count
        mu    sync.Mutex
}

func NewRepository() *Repository <span class="cov6" title="4">{
        return &amp;Repository{carts: make(map[int64]map[int64]uint16)}
}</span>

func (r *Repository) AddItemToUserCart(ctx context.Context, cart models.CartRequest) error <span class="cov10" title="9">{
        r.mu.Lock()
        defer r.mu.Unlock()
        if r.carts[cart.UserID] == nil </span><span class="cov8" title="7">{
                r.carts[cart.UserID] = make(map[int64]uint16)
        }</span>

        <span class="cov10" title="9">r.carts[cart.UserID][cart.SkuID] += cart.Count

        return nil</span>
}

func (r *Repository) DeleteItemFromUserCart(ctx context.Context, userID, skuID int64) error <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        delete(r.carts[userID], skuID)

        return nil
}</span>

func (r *Repository) ClearUserCart(ctx context.Context, userID int64) error <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        delete(r.carts, userID)

        return nil
}</span>

func (r *Repository) ListUserCart(ctx context.Context, userID int64) ([]models.CartItem, error) <span class="cov7" title="5">{
        r.mu.Lock()
        defer r.mu.Unlock()

        userCart, exists := r.carts[userID]
        if !exists || len(userCart) == 0 </span><span class="cov5" title="3">{
                return nil, nil
        }</span>

        <span class="cov3" title="2">items := make([]models.CartItem, 0, len(userCart))
        for skuID, count := range userCart </span><span class="cov5" title="3">{
                items = append(items,
                        models.CartItem{
                                SkuID: skuID,
                                Count: count,
                        })
        }</span>

        <span class="cov3" title="2">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/cart/internal/service.cartRepository -o cart_repository_mock.go -n CartRepositoryMock -p mocks

import (
        "context"
        "route256/cart/internal/models"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements service.cartRepository
type CartRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcAddItemToUserCart          func(ctx context.Context, cart models.CartRequest) (err error)
        inspectFuncAddItemToUserCart   func(ctx context.Context, cart models.CartRequest)
        afterAddItemToUserCartCounter  uint64
        beforeAddItemToUserCartCounter uint64
        AddItemToUserCartMock          mCartRepositoryMockAddItemToUserCart

        funcClearUserCart          func(ctx context.Context, userID int64) (err error)
        inspectFuncClearUserCart   func(ctx context.Context, userID int64)
        afterClearUserCartCounter  uint64
        beforeClearUserCartCounter uint64
        ClearUserCartMock          mCartRepositoryMockClearUserCart

        funcDeleteItemFromUserCart          func(ctx context.Context, userID int64, skuID int64) (err error)
        inspectFuncDeleteItemFromUserCart   func(ctx context.Context, userID int64, skuID int64)
        afterDeleteItemFromUserCartCounter  uint64
        beforeDeleteItemFromUserCartCounter uint64
        DeleteItemFromUserCartMock          mCartRepositoryMockDeleteItemFromUserCart

        funcListUserCart          func(ctx context.Context, userID int64) (ca1 []models.CartItem, err error)
        inspectFuncListUserCart   func(ctx context.Context, userID int64)
        afterListUserCartCounter  uint64
        beforeListUserCartCounter uint64
        ListUserCartMock          mCartRepositoryMockListUserCart
}

// NewCartRepositoryMock returns a mock for service.cartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock <span class="cov6" title="8">{
        m := &amp;CartRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov6" title="8">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov6" title="8">m.AddItemToUserCartMock = mCartRepositoryMockAddItemToUserCart{mock: m}
        m.AddItemToUserCartMock.callArgs = []*CartRepositoryMockAddItemToUserCartParams{}

        m.ClearUserCartMock = mCartRepositoryMockClearUserCart{mock: m}
        m.ClearUserCartMock.callArgs = []*CartRepositoryMockClearUserCartParams{}

        m.DeleteItemFromUserCartMock = mCartRepositoryMockDeleteItemFromUserCart{mock: m}
        m.DeleteItemFromUserCartMock.callArgs = []*CartRepositoryMockDeleteItemFromUserCartParams{}

        m.ListUserCartMock = mCartRepositoryMockListUserCart{mock: m}
        m.ListUserCartMock.callArgs = []*CartRepositoryMockListUserCartParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mCartRepositoryMockAddItemToUserCart struct {
        optional           bool
        mock               *CartRepositoryMock
        defaultExpectation *CartRepositoryMockAddItemToUserCartExpectation
        expectations       []*CartRepositoryMockAddItemToUserCartExpectation

        callArgs []*CartRepositoryMockAddItemToUserCartParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// CartRepositoryMockAddItemToUserCartExpectation specifies expectation struct of the cartRepository.AddItemToUserCart
type CartRepositoryMockAddItemToUserCartExpectation struct {
        mock      *CartRepositoryMock
        params    *CartRepositoryMockAddItemToUserCartParams
        paramPtrs *CartRepositoryMockAddItemToUserCartParamPtrs
        results   *CartRepositoryMockAddItemToUserCartResults
        Counter   uint64
}

// CartRepositoryMockAddItemToUserCartParams contains parameters of the cartRepository.AddItemToUserCart
type CartRepositoryMockAddItemToUserCartParams struct {
        ctx  context.Context
        cart models.CartRequest
}

// CartRepositoryMockAddItemToUserCartParamPtrs contains pointers to parameters of the cartRepository.AddItemToUserCart
type CartRepositoryMockAddItemToUserCartParamPtrs struct {
        ctx  *context.Context
        cart *models.CartRequest
}

// CartRepositoryMockAddItemToUserCartResults contains results of the cartRepository.AddItemToUserCart
type CartRepositoryMockAddItemToUserCartResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Optional() *mCartRepositoryMockAddItemToUserCart <span class="cov0" title="0">{
        mmAddItemToUserCart.optional = true
        return mmAddItemToUserCart
}</span>

// Expect sets up expected params for cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Expect(ctx context.Context, cart models.CartRequest) *mCartRepositoryMockAddItemToUserCart <span class="cov0" title="0">{
        if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.defaultExpectation = &amp;CartRepositoryMockAddItemToUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmAddItemToUserCart.defaultExpectation.params = &amp;CartRepositoryMockAddItemToUserCartParams{ctx, cart}
        for _, e := range mmAddItemToUserCart.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmAddItemToUserCart.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmAddItemToUserCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItemToUserCart.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmAddItemToUserCart</span>
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockAddItemToUserCart <span class="cov0" title="0">{
        if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.defaultExpectation = &amp;CartRepositoryMockAddItemToUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockAddItemToUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAddItemToUserCart.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmAddItemToUserCart</span>
}

// ExpectCartParam2 sets up expected param cart for cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) ExpectCartParam2(cart models.CartRequest) *mCartRepositoryMockAddItemToUserCart <span class="cov0" title="0">{
        if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.defaultExpectation = &amp;CartRepositoryMockAddItemToUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAddItemToUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockAddItemToUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAddItemToUserCart.defaultExpectation.paramPtrs.cart = &amp;cart

        return mmAddItemToUserCart</span>
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Inspect(f func(ctx context.Context, cart models.CartRequest)) *mCartRepositoryMockAddItemToUserCart <span class="cov0" title="0">{
        if mmAddItemToUserCart.mock.inspectFuncAddItemToUserCart != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.AddItemToUserCart")
        }</span>

        <span class="cov0" title="0">mmAddItemToUserCart.mock.inspectFuncAddItemToUserCart = f

        return mmAddItemToUserCart</span>
}

// Return sets up results that will be returned by cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Return(err error) *CartRepositoryMock <span class="cov1" title="1">{
        if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
        }</span>

        <span class="cov1" title="1">if mmAddItemToUserCart.defaultExpectation == nil </span><span class="cov1" title="1">{
                mmAddItemToUserCart.defaultExpectation = &amp;CartRepositoryMockAddItemToUserCartExpectation{mock: mmAddItemToUserCart.mock}
        }</span>
        <span class="cov1" title="1">mmAddItemToUserCart.defaultExpectation.results = &amp;CartRepositoryMockAddItemToUserCartResults{err}
        return mmAddItemToUserCart.mock</span>
}

// Set uses given function f to mock the cartRepository.AddItemToUserCart method
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Set(f func(ctx context.Context, cart models.CartRequest) (err error)) *CartRepositoryMock <span class="cov0" title="0">{
        if mmAddItemToUserCart.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("Default expectation is already set for the cartRepository.AddItemToUserCart method")
        }</span>

        <span class="cov0" title="0">if len(mmAddItemToUserCart.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("Some expectations are already set for the cartRepository.AddItemToUserCart method")
        }</span>

        <span class="cov0" title="0">mmAddItemToUserCart.mock.funcAddItemToUserCart = f
        return mmAddItemToUserCart.mock</span>
}

// When sets expectation for the cartRepository.AddItemToUserCart which will trigger the result defined by the following
// Then helper
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) When(ctx context.Context, cart models.CartRequest) *CartRepositoryMockAddItemToUserCartExpectation <span class="cov0" title="0">{
        if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CartRepositoryMockAddItemToUserCartExpectation{
                mock:   mmAddItemToUserCart.mock,
                params: &amp;CartRepositoryMockAddItemToUserCartParams{ctx, cart},
        }
        mmAddItemToUserCart.expectations = append(mmAddItemToUserCart.expectations, expectation)
        return expectation</span>
}

// Then sets up cartRepository.AddItemToUserCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddItemToUserCartExpectation) Then(err error) *CartRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;CartRepositoryMockAddItemToUserCartResults{err}
        return e.mock
}</span>

// Times sets number of times cartRepository.AddItemToUserCart should be invoked
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Times(n uint64) *mCartRepositoryMockAddItemToUserCart <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmAddItemToUserCart.mock.t.Fatalf("Times of CartRepositoryMock.AddItemToUserCart mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmAddItemToUserCart.expectedInvocations, n)
        return mmAddItemToUserCart</span>
}

func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) invocationsDone() bool <span class="cov6" title="8">{
        if len(mmAddItemToUserCart.expectations) == 0 &amp;&amp; mmAddItemToUserCart.defaultExpectation == nil &amp;&amp; mmAddItemToUserCart.mock.funcAddItemToUserCart == nil </span><span class="cov6" title="7">{
                return true
        }</span>

        <span class="cov1" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmAddItemToUserCart.mock.afterAddItemToUserCartCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmAddItemToUserCart.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// AddItemToUserCart implements service.cartRepository
func (mmAddItemToUserCart *CartRepositoryMock) AddItemToUserCart(ctx context.Context, cart models.CartRequest) (err error) <span class="cov1" title="1">{
        mm_atomic.AddUint64(&amp;mmAddItemToUserCart.beforeAddItemToUserCartCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmAddItemToUserCart.afterAddItemToUserCartCounter, 1)

        if mmAddItemToUserCart.inspectFuncAddItemToUserCart != nil </span><span class="cov0" title="0">{
                mmAddItemToUserCart.inspectFuncAddItemToUserCart(ctx, cart)
        }</span>

        <span class="cov1" title="1">mm_params := CartRepositoryMockAddItemToUserCartParams{ctx, cart}

        // Record call args
        mmAddItemToUserCart.AddItemToUserCartMock.mutex.Lock()
        mmAddItemToUserCart.AddItemToUserCartMock.callArgs = append(mmAddItemToUserCart.AddItemToUserCartMock.callArgs, &amp;mm_params)
        mmAddItemToUserCart.AddItemToUserCartMock.mutex.Unlock()

        for _, e := range mmAddItemToUserCart.AddItemToUserCartMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov1" title="1">if mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation != nil </span><span class="cov1" title="1">{
                mm_atomic.AddUint64(&amp;mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation.Counter, 1)
                mm_want := mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation.params
                mm_want_ptrs := mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation.paramPtrs

                mm_got := CartRepositoryMockAddItemToUserCartParams{ctx, cart}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmAddItemToUserCart.t.Errorf("CartRepositoryMock.AddItemToUserCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.cart != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.cart, mm_got.cart) </span><span class="cov0" title="0">{
                                mmAddItemToUserCart.t.Errorf("CartRepositoryMock.AddItemToUserCart got unexpected parameter cart, want: %#v, got: %#v%s\n", *mm_want_ptrs.cart, mm_got.cart, minimock.Diff(*mm_want_ptrs.cart, mm_got.cart))
                        }</span>

                } else<span class="cov1" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmAddItemToUserCart.t.Errorf("CartRepositoryMock.AddItemToUserCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov1" title="1">mm_results := mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmAddItemToUserCart.t.Fatal("No results are set for the CartRepositoryMock.AddItemToUserCart")
                }</span>
                <span class="cov1" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmAddItemToUserCart.funcAddItemToUserCart != nil </span><span class="cov0" title="0">{
                return mmAddItemToUserCart.funcAddItemToUserCart(ctx, cart)
        }</span>
        <span class="cov0" title="0">mmAddItemToUserCart.t.Fatalf("Unexpected call to CartRepositoryMock.AddItemToUserCart. %v %v", ctx, cart)
        return</span>
}

// AddItemToUserCartAfterCounter returns a count of finished CartRepositoryMock.AddItemToUserCart invocations
func (mmAddItemToUserCart *CartRepositoryMock) AddItemToUserCartAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAddItemToUserCart.afterAddItemToUserCartCounter)
}</span>

// AddItemToUserCartBeforeCounter returns a count of CartRepositoryMock.AddItemToUserCart invocations
func (mmAddItemToUserCart *CartRepositoryMock) AddItemToUserCartBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAddItemToUserCart.beforeAddItemToUserCartCounter)
}</span>

// Calls returns a list of arguments used in each call to CartRepositoryMock.AddItemToUserCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Calls() []*CartRepositoryMockAddItemToUserCartParams <span class="cov0" title="0">{
        mmAddItemToUserCart.mutex.RLock()

        argCopy := make([]*CartRepositoryMockAddItemToUserCartParams, len(mmAddItemToUserCart.callArgs))
        copy(argCopy, mmAddItemToUserCart.callArgs)

        mmAddItemToUserCart.mutex.RUnlock()

        return argCopy
}</span>

// MinimockAddItemToUserCartDone returns true if the count of the AddItemToUserCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddItemToUserCartDone() bool <span class="cov6" title="8">{
        if m.AddItemToUserCartMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov6" title="8">for _, e := range m.AddItemToUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov6" title="8">return m.AddItemToUserCartMock.invocationsDone()</span>
}

// MinimockAddItemToUserCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddItemToUserCartInspect() <span class="cov0" title="0">{
        for _, e := range m.AddItemToUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CartRepositoryMock.AddItemToUserCart with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterAddItemToUserCartCounter := mm_atomic.LoadUint64(&amp;m.afterAddItemToUserCartCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.AddItemToUserCartMock.defaultExpectation != nil &amp;&amp; afterAddItemToUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.AddItemToUserCartMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to CartRepositoryMock.AddItemToUserCart")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CartRepositoryMock.AddItemToUserCart with params: %#v", *m.AddItemToUserCartMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcAddItemToUserCart != nil &amp;&amp; afterAddItemToUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to CartRepositoryMock.AddItemToUserCart")
        }</span>

        <span class="cov0" title="0">if !m.AddItemToUserCartMock.invocationsDone() &amp;&amp; afterAddItemToUserCartCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CartRepositoryMock.AddItemToUserCart but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.AddItemToUserCartMock.expectedInvocations), afterAddItemToUserCartCounter)
        }</span>
}

type mCartRepositoryMockClearUserCart struct {
        optional           bool
        mock               *CartRepositoryMock
        defaultExpectation *CartRepositoryMockClearUserCartExpectation
        expectations       []*CartRepositoryMockClearUserCartExpectation

        callArgs []*CartRepositoryMockClearUserCartParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// CartRepositoryMockClearUserCartExpectation specifies expectation struct of the cartRepository.ClearUserCart
type CartRepositoryMockClearUserCartExpectation struct {
        mock      *CartRepositoryMock
        params    *CartRepositoryMockClearUserCartParams
        paramPtrs *CartRepositoryMockClearUserCartParamPtrs
        results   *CartRepositoryMockClearUserCartResults
        Counter   uint64
}

// CartRepositoryMockClearUserCartParams contains parameters of the cartRepository.ClearUserCart
type CartRepositoryMockClearUserCartParams struct {
        ctx    context.Context
        userID int64
}

// CartRepositoryMockClearUserCartParamPtrs contains pointers to parameters of the cartRepository.ClearUserCart
type CartRepositoryMockClearUserCartParamPtrs struct {
        ctx    *context.Context
        userID *int64
}

// CartRepositoryMockClearUserCartResults contains results of the cartRepository.ClearUserCart
type CartRepositoryMockClearUserCartResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Optional() *mCartRepositoryMockClearUserCart <span class="cov0" title="0">{
        mmClearUserCart.optional = true
        return mmClearUserCart
}</span>

// Expect sets up expected params for cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Expect(ctx context.Context, userID int64) *mCartRepositoryMockClearUserCart <span class="cov0" title="0">{
        if mmClearUserCart.mock.funcClearUserCart != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmClearUserCart.defaultExpectation = &amp;CartRepositoryMockClearUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmClearUserCart.defaultExpectation.params = &amp;CartRepositoryMockClearUserCartParams{ctx, userID}
        for _, e := range mmClearUserCart.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmClearUserCart.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmClearUserCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearUserCart.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmClearUserCart</span>
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockClearUserCart <span class="cov0" title="0">{
        if mmClearUserCart.mock.funcClearUserCart != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmClearUserCart.defaultExpectation = &amp;CartRepositoryMockClearUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmClearUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockClearUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmClearUserCart.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmClearUserCart</span>
}

// ExpectUserIDParam2 sets up expected param userID for cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) ExpectUserIDParam2(userID int64) *mCartRepositoryMockClearUserCart <span class="cov0" title="0">{
        if mmClearUserCart.mock.funcClearUserCart != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmClearUserCart.defaultExpectation = &amp;CartRepositoryMockClearUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmClearUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmClearUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockClearUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmClearUserCart.defaultExpectation.paramPtrs.userID = &amp;userID

        return mmClearUserCart</span>
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Inspect(f func(ctx context.Context, userID int64)) *mCartRepositoryMockClearUserCart <span class="cov0" title="0">{
        if mmClearUserCart.mock.inspectFuncClearUserCart != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ClearUserCart")
        }</span>

        <span class="cov0" title="0">mmClearUserCart.mock.inspectFuncClearUserCart = f

        return mmClearUserCart</span>
}

// Return sets up results that will be returned by cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Return(err error) *CartRepositoryMock <span class="cov1" title="1">{
        if mmClearUserCart.mock.funcClearUserCart != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
        }</span>

        <span class="cov1" title="1">if mmClearUserCart.defaultExpectation == nil </span><span class="cov1" title="1">{
                mmClearUserCart.defaultExpectation = &amp;CartRepositoryMockClearUserCartExpectation{mock: mmClearUserCart.mock}
        }</span>
        <span class="cov1" title="1">mmClearUserCart.defaultExpectation.results = &amp;CartRepositoryMockClearUserCartResults{err}
        return mmClearUserCart.mock</span>
}

// Set uses given function f to mock the cartRepository.ClearUserCart method
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Set(f func(ctx context.Context, userID int64) (err error)) *CartRepositoryMock <span class="cov0" title="0">{
        if mmClearUserCart.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("Default expectation is already set for the cartRepository.ClearUserCart method")
        }</span>

        <span class="cov0" title="0">if len(mmClearUserCart.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("Some expectations are already set for the cartRepository.ClearUserCart method")
        }</span>

        <span class="cov0" title="0">mmClearUserCart.mock.funcClearUserCart = f
        return mmClearUserCart.mock</span>
}

// When sets expectation for the cartRepository.ClearUserCart which will trigger the result defined by the following
// Then helper
func (mmClearUserCart *mCartRepositoryMockClearUserCart) When(ctx context.Context, userID int64) *CartRepositoryMockClearUserCartExpectation <span class="cov0" title="0">{
        if mmClearUserCart.mock.funcClearUserCart != nil </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CartRepositoryMockClearUserCartExpectation{
                mock:   mmClearUserCart.mock,
                params: &amp;CartRepositoryMockClearUserCartParams{ctx, userID},
        }
        mmClearUserCart.expectations = append(mmClearUserCart.expectations, expectation)
        return expectation</span>
}

// Then sets up cartRepository.ClearUserCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockClearUserCartExpectation) Then(err error) *CartRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;CartRepositoryMockClearUserCartResults{err}
        return e.mock
}</span>

// Times sets number of times cartRepository.ClearUserCart should be invoked
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Times(n uint64) *mCartRepositoryMockClearUserCart <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmClearUserCart.mock.t.Fatalf("Times of CartRepositoryMock.ClearUserCart mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmClearUserCart.expectedInvocations, n)
        return mmClearUserCart</span>
}

func (mmClearUserCart *mCartRepositoryMockClearUserCart) invocationsDone() bool <span class="cov6" title="8">{
        if len(mmClearUserCart.expectations) == 0 &amp;&amp; mmClearUserCart.defaultExpectation == nil &amp;&amp; mmClearUserCart.mock.funcClearUserCart == nil </span><span class="cov6" title="7">{
                return true
        }</span>

        <span class="cov1" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmClearUserCart.mock.afterClearUserCartCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmClearUserCart.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ClearUserCart implements service.cartRepository
func (mmClearUserCart *CartRepositoryMock) ClearUserCart(ctx context.Context, userID int64) (err error) <span class="cov1" title="1">{
        mm_atomic.AddUint64(&amp;mmClearUserCart.beforeClearUserCartCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmClearUserCart.afterClearUserCartCounter, 1)

        if mmClearUserCart.inspectFuncClearUserCart != nil </span><span class="cov0" title="0">{
                mmClearUserCart.inspectFuncClearUserCart(ctx, userID)
        }</span>

        <span class="cov1" title="1">mm_params := CartRepositoryMockClearUserCartParams{ctx, userID}

        // Record call args
        mmClearUserCart.ClearUserCartMock.mutex.Lock()
        mmClearUserCart.ClearUserCartMock.callArgs = append(mmClearUserCart.ClearUserCartMock.callArgs, &amp;mm_params)
        mmClearUserCart.ClearUserCartMock.mutex.Unlock()

        for _, e := range mmClearUserCart.ClearUserCartMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov1" title="1">if mmClearUserCart.ClearUserCartMock.defaultExpectation != nil </span><span class="cov1" title="1">{
                mm_atomic.AddUint64(&amp;mmClearUserCart.ClearUserCartMock.defaultExpectation.Counter, 1)
                mm_want := mmClearUserCart.ClearUserCartMock.defaultExpectation.params
                mm_want_ptrs := mmClearUserCart.ClearUserCartMock.defaultExpectation.paramPtrs

                mm_got := CartRepositoryMockClearUserCartParams{ctx, userID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmClearUserCart.t.Errorf("CartRepositoryMock.ClearUserCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.userID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) </span><span class="cov0" title="0">{
                                mmClearUserCart.t.Errorf("CartRepositoryMock.ClearUserCart got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
                        }</span>

                } else<span class="cov1" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmClearUserCart.t.Errorf("CartRepositoryMock.ClearUserCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov1" title="1">mm_results := mmClearUserCart.ClearUserCartMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmClearUserCart.t.Fatal("No results are set for the CartRepositoryMock.ClearUserCart")
                }</span>
                <span class="cov1" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmClearUserCart.funcClearUserCart != nil </span><span class="cov0" title="0">{
                return mmClearUserCart.funcClearUserCart(ctx, userID)
        }</span>
        <span class="cov0" title="0">mmClearUserCart.t.Fatalf("Unexpected call to CartRepositoryMock.ClearUserCart. %v %v", ctx, userID)
        return</span>
}

// ClearUserCartAfterCounter returns a count of finished CartRepositoryMock.ClearUserCart invocations
func (mmClearUserCart *CartRepositoryMock) ClearUserCartAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmClearUserCart.afterClearUserCartCounter)
}</span>

// ClearUserCartBeforeCounter returns a count of CartRepositoryMock.ClearUserCart invocations
func (mmClearUserCart *CartRepositoryMock) ClearUserCartBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmClearUserCart.beforeClearUserCartCounter)
}</span>

// Calls returns a list of arguments used in each call to CartRepositoryMock.ClearUserCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Calls() []*CartRepositoryMockClearUserCartParams <span class="cov0" title="0">{
        mmClearUserCart.mutex.RLock()

        argCopy := make([]*CartRepositoryMockClearUserCartParams, len(mmClearUserCart.callArgs))
        copy(argCopy, mmClearUserCart.callArgs)

        mmClearUserCart.mutex.RUnlock()

        return argCopy
}</span>

// MinimockClearUserCartDone returns true if the count of the ClearUserCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockClearUserCartDone() bool <span class="cov6" title="8">{
        if m.ClearUserCartMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov6" title="8">for _, e := range m.ClearUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov6" title="8">return m.ClearUserCartMock.invocationsDone()</span>
}

// MinimockClearUserCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockClearUserCartInspect() <span class="cov0" title="0">{
        for _, e := range m.ClearUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CartRepositoryMock.ClearUserCart with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterClearUserCartCounter := mm_atomic.LoadUint64(&amp;m.afterClearUserCartCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ClearUserCartMock.defaultExpectation != nil &amp;&amp; afterClearUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ClearUserCartMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to CartRepositoryMock.ClearUserCart")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CartRepositoryMock.ClearUserCart with params: %#v", *m.ClearUserCartMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcClearUserCart != nil &amp;&amp; afterClearUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to CartRepositoryMock.ClearUserCart")
        }</span>

        <span class="cov0" title="0">if !m.ClearUserCartMock.invocationsDone() &amp;&amp; afterClearUserCartCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CartRepositoryMock.ClearUserCart but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ClearUserCartMock.expectedInvocations), afterClearUserCartCounter)
        }</span>
}

type mCartRepositoryMockDeleteItemFromUserCart struct {
        optional           bool
        mock               *CartRepositoryMock
        defaultExpectation *CartRepositoryMockDeleteItemFromUserCartExpectation
        expectations       []*CartRepositoryMockDeleteItemFromUserCartExpectation

        callArgs []*CartRepositoryMockDeleteItemFromUserCartParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// CartRepositoryMockDeleteItemFromUserCartExpectation specifies expectation struct of the cartRepository.DeleteItemFromUserCart
type CartRepositoryMockDeleteItemFromUserCartExpectation struct {
        mock      *CartRepositoryMock
        params    *CartRepositoryMockDeleteItemFromUserCartParams
        paramPtrs *CartRepositoryMockDeleteItemFromUserCartParamPtrs
        results   *CartRepositoryMockDeleteItemFromUserCartResults
        Counter   uint64
}

// CartRepositoryMockDeleteItemFromUserCartParams contains parameters of the cartRepository.DeleteItemFromUserCart
type CartRepositoryMockDeleteItemFromUserCartParams struct {
        ctx    context.Context
        userID int64
        skuID  int64
}

// CartRepositoryMockDeleteItemFromUserCartParamPtrs contains pointers to parameters of the cartRepository.DeleteItemFromUserCart
type CartRepositoryMockDeleteItemFromUserCartParamPtrs struct {
        ctx    *context.Context
        userID *int64
        skuID  *int64
}

// CartRepositoryMockDeleteItemFromUserCartResults contains results of the cartRepository.DeleteItemFromUserCart
type CartRepositoryMockDeleteItemFromUserCartResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Optional() *mCartRepositoryMockDeleteItemFromUserCart <span class="cov0" title="0">{
        mmDeleteItemFromUserCart.optional = true
        return mmDeleteItemFromUserCart
}</span>

// Expect sets up expected params for cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Expect(ctx context.Context, userID int64, skuID int64) *mCartRepositoryMockDeleteItemFromUserCart <span class="cov0" title="0">{
        if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.defaultExpectation = &amp;CartRepositoryMockDeleteItemFromUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmDeleteItemFromUserCart.defaultExpectation.params = &amp;CartRepositoryMockDeleteItemFromUserCartParams{ctx, userID, skuID}
        for _, e := range mmDeleteItemFromUserCart.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmDeleteItemFromUserCart.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmDeleteItemFromUserCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItemFromUserCart.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmDeleteItemFromUserCart</span>
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDeleteItemFromUserCart <span class="cov0" title="0">{
        if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.defaultExpectation = &amp;CartRepositoryMockDeleteItemFromUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockDeleteItemFromUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteItemFromUserCart.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmDeleteItemFromUserCart</span>
}

// ExpectUserIDParam2 sets up expected param userID for cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) ExpectUserIDParam2(userID int64) *mCartRepositoryMockDeleteItemFromUserCart <span class="cov0" title="0">{
        if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.defaultExpectation = &amp;CartRepositoryMockDeleteItemFromUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockDeleteItemFromUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteItemFromUserCart.defaultExpectation.paramPtrs.userID = &amp;userID

        return mmDeleteItemFromUserCart</span>
}

// ExpectSkuIDParam3 sets up expected param skuID for cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) ExpectSkuIDParam3(skuID int64) *mCartRepositoryMockDeleteItemFromUserCart <span class="cov0" title="0">{
        if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.defaultExpectation = &amp;CartRepositoryMockDeleteItemFromUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteItemFromUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockDeleteItemFromUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteItemFromUserCart.defaultExpectation.paramPtrs.skuID = &amp;skuID

        return mmDeleteItemFromUserCart</span>
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Inspect(f func(ctx context.Context, userID int64, skuID int64)) *mCartRepositoryMockDeleteItemFromUserCart <span class="cov0" title="0">{
        if mmDeleteItemFromUserCart.mock.inspectFuncDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteItemFromUserCart")
        }</span>

        <span class="cov0" title="0">mmDeleteItemFromUserCart.mock.inspectFuncDeleteItemFromUserCart = f

        return mmDeleteItemFromUserCart</span>
}

// Return sets up results that will be returned by cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Return(err error) *CartRepositoryMock <span class="cov1" title="1">{
        if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
        }</span>

        <span class="cov1" title="1">if mmDeleteItemFromUserCart.defaultExpectation == nil </span><span class="cov1" title="1">{
                mmDeleteItemFromUserCart.defaultExpectation = &amp;CartRepositoryMockDeleteItemFromUserCartExpectation{mock: mmDeleteItemFromUserCart.mock}
        }</span>
        <span class="cov1" title="1">mmDeleteItemFromUserCart.defaultExpectation.results = &amp;CartRepositoryMockDeleteItemFromUserCartResults{err}
        return mmDeleteItemFromUserCart.mock</span>
}

// Set uses given function f to mock the cartRepository.DeleteItemFromUserCart method
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Set(f func(ctx context.Context, userID int64, skuID int64) (err error)) *CartRepositoryMock <span class="cov0" title="0">{
        if mmDeleteItemFromUserCart.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("Default expectation is already set for the cartRepository.DeleteItemFromUserCart method")
        }</span>

        <span class="cov0" title="0">if len(mmDeleteItemFromUserCart.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("Some expectations are already set for the cartRepository.DeleteItemFromUserCart method")
        }</span>

        <span class="cov0" title="0">mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart = f
        return mmDeleteItemFromUserCart.mock</span>
}

// When sets expectation for the cartRepository.DeleteItemFromUserCart which will trigger the result defined by the following
// Then helper
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) When(ctx context.Context, userID int64, skuID int64) *CartRepositoryMockDeleteItemFromUserCartExpectation <span class="cov0" title="0">{
        if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CartRepositoryMockDeleteItemFromUserCartExpectation{
                mock:   mmDeleteItemFromUserCart.mock,
                params: &amp;CartRepositoryMockDeleteItemFromUserCartParams{ctx, userID, skuID},
        }
        mmDeleteItemFromUserCart.expectations = append(mmDeleteItemFromUserCart.expectations, expectation)
        return expectation</span>
}

// Then sets up cartRepository.DeleteItemFromUserCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteItemFromUserCartExpectation) Then(err error) *CartRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;CartRepositoryMockDeleteItemFromUserCartResults{err}
        return e.mock
}</span>

// Times sets number of times cartRepository.DeleteItemFromUserCart should be invoked
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Times(n uint64) *mCartRepositoryMockDeleteItemFromUserCart <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.mock.t.Fatalf("Times of CartRepositoryMock.DeleteItemFromUserCart mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmDeleteItemFromUserCart.expectedInvocations, n)
        return mmDeleteItemFromUserCart</span>
}

func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) invocationsDone() bool <span class="cov6" title="8">{
        if len(mmDeleteItemFromUserCart.expectations) == 0 &amp;&amp; mmDeleteItemFromUserCart.defaultExpectation == nil &amp;&amp; mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart == nil </span><span class="cov6" title="7">{
                return true
        }</span>

        <span class="cov1" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmDeleteItemFromUserCart.mock.afterDeleteItemFromUserCartCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmDeleteItemFromUserCart.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// DeleteItemFromUserCart implements service.cartRepository
func (mmDeleteItemFromUserCart *CartRepositoryMock) DeleteItemFromUserCart(ctx context.Context, userID int64, skuID int64) (err error) <span class="cov1" title="1">{
        mm_atomic.AddUint64(&amp;mmDeleteItemFromUserCart.beforeDeleteItemFromUserCartCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmDeleteItemFromUserCart.afterDeleteItemFromUserCartCounter, 1)

        if mmDeleteItemFromUserCart.inspectFuncDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                mmDeleteItemFromUserCart.inspectFuncDeleteItemFromUserCart(ctx, userID, skuID)
        }</span>

        <span class="cov1" title="1">mm_params := CartRepositoryMockDeleteItemFromUserCartParams{ctx, userID, skuID}

        // Record call args
        mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.mutex.Lock()
        mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.callArgs = append(mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.callArgs, &amp;mm_params)
        mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.mutex.Unlock()

        for _, e := range mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov1" title="1">if mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation != nil </span><span class="cov1" title="1">{
                mm_atomic.AddUint64(&amp;mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation.Counter, 1)
                mm_want := mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation.params
                mm_want_ptrs := mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation.paramPtrs

                mm_got := CartRepositoryMockDeleteItemFromUserCartParams{ctx, userID, skuID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmDeleteItemFromUserCart.t.Errorf("CartRepositoryMock.DeleteItemFromUserCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.userID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) </span><span class="cov0" title="0">{
                                mmDeleteItemFromUserCart.t.Errorf("CartRepositoryMock.DeleteItemFromUserCart got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.skuID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) </span><span class="cov0" title="0">{
                                mmDeleteItemFromUserCart.t.Errorf("CartRepositoryMock.DeleteItemFromUserCart got unexpected parameter skuID, want: %#v, got: %#v%s\n", *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
                        }</span>

                } else<span class="cov1" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmDeleteItemFromUserCart.t.Errorf("CartRepositoryMock.DeleteItemFromUserCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov1" title="1">mm_results := mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmDeleteItemFromUserCart.t.Fatal("No results are set for the CartRepositoryMock.DeleteItemFromUserCart")
                }</span>
                <span class="cov1" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmDeleteItemFromUserCart.funcDeleteItemFromUserCart != nil </span><span class="cov0" title="0">{
                return mmDeleteItemFromUserCart.funcDeleteItemFromUserCart(ctx, userID, skuID)
        }</span>
        <span class="cov0" title="0">mmDeleteItemFromUserCart.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteItemFromUserCart. %v %v %v", ctx, userID, skuID)
        return</span>
}

// DeleteItemFromUserCartAfterCounter returns a count of finished CartRepositoryMock.DeleteItemFromUserCart invocations
func (mmDeleteItemFromUserCart *CartRepositoryMock) DeleteItemFromUserCartAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteItemFromUserCart.afterDeleteItemFromUserCartCounter)
}</span>

// DeleteItemFromUserCartBeforeCounter returns a count of CartRepositoryMock.DeleteItemFromUserCart invocations
func (mmDeleteItemFromUserCart *CartRepositoryMock) DeleteItemFromUserCartBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteItemFromUserCart.beforeDeleteItemFromUserCartCounter)
}</span>

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteItemFromUserCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Calls() []*CartRepositoryMockDeleteItemFromUserCartParams <span class="cov0" title="0">{
        mmDeleteItemFromUserCart.mutex.RLock()

        argCopy := make([]*CartRepositoryMockDeleteItemFromUserCartParams, len(mmDeleteItemFromUserCart.callArgs))
        copy(argCopy, mmDeleteItemFromUserCart.callArgs)

        mmDeleteItemFromUserCart.mutex.RUnlock()

        return argCopy
}</span>

// MinimockDeleteItemFromUserCartDone returns true if the count of the DeleteItemFromUserCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteItemFromUserCartDone() bool <span class="cov6" title="8">{
        if m.DeleteItemFromUserCartMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov6" title="8">for _, e := range m.DeleteItemFromUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov6" title="8">return m.DeleteItemFromUserCartMock.invocationsDone()</span>
}

// MinimockDeleteItemFromUserCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteItemFromUserCartInspect() <span class="cov0" title="0">{
        for _, e := range m.DeleteItemFromUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CartRepositoryMock.DeleteItemFromUserCart with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterDeleteItemFromUserCartCounter := mm_atomic.LoadUint64(&amp;m.afterDeleteItemFromUserCartCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.DeleteItemFromUserCartMock.defaultExpectation != nil &amp;&amp; afterDeleteItemFromUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.DeleteItemFromUserCartMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to CartRepositoryMock.DeleteItemFromUserCart")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CartRepositoryMock.DeleteItemFromUserCart with params: %#v", *m.DeleteItemFromUserCartMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcDeleteItemFromUserCart != nil &amp;&amp; afterDeleteItemFromUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to CartRepositoryMock.DeleteItemFromUserCart")
        }</span>

        <span class="cov0" title="0">if !m.DeleteItemFromUserCartMock.invocationsDone() &amp;&amp; afterDeleteItemFromUserCartCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteItemFromUserCart but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.DeleteItemFromUserCartMock.expectedInvocations), afterDeleteItemFromUserCartCounter)
        }</span>
}

type mCartRepositoryMockListUserCart struct {
        optional           bool
        mock               *CartRepositoryMock
        defaultExpectation *CartRepositoryMockListUserCartExpectation
        expectations       []*CartRepositoryMockListUserCartExpectation

        callArgs []*CartRepositoryMockListUserCartParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// CartRepositoryMockListUserCartExpectation specifies expectation struct of the cartRepository.ListUserCart
type CartRepositoryMockListUserCartExpectation struct {
        mock      *CartRepositoryMock
        params    *CartRepositoryMockListUserCartParams
        paramPtrs *CartRepositoryMockListUserCartParamPtrs
        results   *CartRepositoryMockListUserCartResults
        Counter   uint64
}

// CartRepositoryMockListUserCartParams contains parameters of the cartRepository.ListUserCart
type CartRepositoryMockListUserCartParams struct {
        ctx    context.Context
        userID int64
}

// CartRepositoryMockListUserCartParamPtrs contains pointers to parameters of the cartRepository.ListUserCart
type CartRepositoryMockListUserCartParamPtrs struct {
        ctx    *context.Context
        userID *int64
}

// CartRepositoryMockListUserCartResults contains results of the cartRepository.ListUserCart
type CartRepositoryMockListUserCartResults struct {
        ca1 []models.CartItem
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListUserCart *mCartRepositoryMockListUserCart) Optional() *mCartRepositoryMockListUserCart <span class="cov0" title="0">{
        mmListUserCart.optional = true
        return mmListUserCart
}</span>

// Expect sets up expected params for cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) Expect(ctx context.Context, userID int64) *mCartRepositoryMockListUserCart <span class="cov0" title="0">{
        if mmListUserCart.mock.funcListUserCart != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListUserCart.defaultExpectation = &amp;CartRepositoryMockListUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmListUserCart.defaultExpectation.params = &amp;CartRepositoryMockListUserCartParams{ctx, userID}
        for _, e := range mmListUserCart.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmListUserCart.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmListUserCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListUserCart.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmListUserCart</span>
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockListUserCart <span class="cov0" title="0">{
        if mmListUserCart.mock.funcListUserCart != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListUserCart.defaultExpectation = &amp;CartRepositoryMockListUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmListUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockListUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmListUserCart.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmListUserCart</span>
}

// ExpectUserIDParam2 sets up expected param userID for cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) ExpectUserIDParam2(userID int64) *mCartRepositoryMockListUserCart <span class="cov0" title="0">{
        if mmListUserCart.mock.funcListUserCart != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmListUserCart.defaultExpectation = &amp;CartRepositoryMockListUserCartExpectation{}
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmListUserCart.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmListUserCart.defaultExpectation.paramPtrs = &amp;CartRepositoryMockListUserCartParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmListUserCart.defaultExpectation.paramPtrs.userID = &amp;userID

        return mmListUserCart</span>
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) Inspect(f func(ctx context.Context, userID int64)) *mCartRepositoryMockListUserCart <span class="cov0" title="0">{
        if mmListUserCart.mock.inspectFuncListUserCart != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ListUserCart")
        }</span>

        <span class="cov0" title="0">mmListUserCart.mock.inspectFuncListUserCart = f

        return mmListUserCart</span>
}

// Return sets up results that will be returned by cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) Return(ca1 []models.CartItem, err error) *CartRepositoryMock <span class="cov4" title="3">{
        if mmListUserCart.mock.funcListUserCart != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
        }</span>

        <span class="cov4" title="3">if mmListUserCart.defaultExpectation == nil </span><span class="cov4" title="3">{
                mmListUserCart.defaultExpectation = &amp;CartRepositoryMockListUserCartExpectation{mock: mmListUserCart.mock}
        }</span>
        <span class="cov4" title="3">mmListUserCart.defaultExpectation.results = &amp;CartRepositoryMockListUserCartResults{ca1, err}
        return mmListUserCart.mock</span>
}

// Set uses given function f to mock the cartRepository.ListUserCart method
func (mmListUserCart *mCartRepositoryMockListUserCart) Set(f func(ctx context.Context, userID int64) (ca1 []models.CartItem, err error)) *CartRepositoryMock <span class="cov0" title="0">{
        if mmListUserCart.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("Default expectation is already set for the cartRepository.ListUserCart method")
        }</span>

        <span class="cov0" title="0">if len(mmListUserCart.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("Some expectations are already set for the cartRepository.ListUserCart method")
        }</span>

        <span class="cov0" title="0">mmListUserCart.mock.funcListUserCart = f
        return mmListUserCart.mock</span>
}

// When sets expectation for the cartRepository.ListUserCart which will trigger the result defined by the following
// Then helper
func (mmListUserCart *mCartRepositoryMockListUserCart) When(ctx context.Context, userID int64) *CartRepositoryMockListUserCartExpectation <span class="cov0" title="0">{
        if mmListUserCart.mock.funcListUserCart != nil </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;CartRepositoryMockListUserCartExpectation{
                mock:   mmListUserCart.mock,
                params: &amp;CartRepositoryMockListUserCartParams{ctx, userID},
        }
        mmListUserCart.expectations = append(mmListUserCart.expectations, expectation)
        return expectation</span>
}

// Then sets up cartRepository.ListUserCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockListUserCartExpectation) Then(ca1 []models.CartItem, err error) *CartRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;CartRepositoryMockListUserCartResults{ca1, err}
        return e.mock
}</span>

// Times sets number of times cartRepository.ListUserCart should be invoked
func (mmListUserCart *mCartRepositoryMockListUserCart) Times(n uint64) *mCartRepositoryMockListUserCart <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmListUserCart.mock.t.Fatalf("Times of CartRepositoryMock.ListUserCart mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmListUserCart.expectedInvocations, n)
        return mmListUserCart</span>
}

func (mmListUserCart *mCartRepositoryMockListUserCart) invocationsDone() bool <span class="cov6" title="8">{
        if len(mmListUserCart.expectations) == 0 &amp;&amp; mmListUserCart.defaultExpectation == nil &amp;&amp; mmListUserCart.mock.funcListUserCart == nil </span><span class="cov5" title="5">{
                return true
        }</span>

        <span class="cov4" title="3">totalInvocations := mm_atomic.LoadUint64(&amp;mmListUserCart.mock.afterListUserCartCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmListUserCart.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// ListUserCart implements service.cartRepository
func (mmListUserCart *CartRepositoryMock) ListUserCart(ctx context.Context, userID int64) (ca1 []models.CartItem, err error) <span class="cov4" title="3">{
        mm_atomic.AddUint64(&amp;mmListUserCart.beforeListUserCartCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmListUserCart.afterListUserCartCounter, 1)

        if mmListUserCart.inspectFuncListUserCart != nil </span><span class="cov0" title="0">{
                mmListUserCart.inspectFuncListUserCart(ctx, userID)
        }</span>

        <span class="cov4" title="3">mm_params := CartRepositoryMockListUserCartParams{ctx, userID}

        // Record call args
        mmListUserCart.ListUserCartMock.mutex.Lock()
        mmListUserCart.ListUserCartMock.callArgs = append(mmListUserCart.ListUserCartMock.callArgs, &amp;mm_params)
        mmListUserCart.ListUserCartMock.mutex.Unlock()

        for _, e := range mmListUserCart.ListUserCartMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.ca1, e.results.err
                }</span>
        }

        <span class="cov4" title="3">if mmListUserCart.ListUserCartMock.defaultExpectation != nil </span><span class="cov4" title="3">{
                mm_atomic.AddUint64(&amp;mmListUserCart.ListUserCartMock.defaultExpectation.Counter, 1)
                mm_want := mmListUserCart.ListUserCartMock.defaultExpectation.params
                mm_want_ptrs := mmListUserCart.ListUserCartMock.defaultExpectation.paramPtrs

                mm_got := CartRepositoryMockListUserCartParams{ctx, userID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmListUserCart.t.Errorf("CartRepositoryMock.ListUserCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.userID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) </span><span class="cov0" title="0">{
                                mmListUserCart.t.Errorf("CartRepositoryMock.ListUserCart got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
                        }</span>

                } else<span class="cov4" title="3"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmListUserCart.t.Errorf("CartRepositoryMock.ListUserCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov4" title="3">mm_results := mmListUserCart.ListUserCartMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmListUserCart.t.Fatal("No results are set for the CartRepositoryMock.ListUserCart")
                }</span>
                <span class="cov4" title="3">return (*mm_results).ca1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmListUserCart.funcListUserCart != nil </span><span class="cov0" title="0">{
                return mmListUserCart.funcListUserCart(ctx, userID)
        }</span>
        <span class="cov0" title="0">mmListUserCart.t.Fatalf("Unexpected call to CartRepositoryMock.ListUserCart. %v %v", ctx, userID)
        return</span>
}

// ListUserCartAfterCounter returns a count of finished CartRepositoryMock.ListUserCart invocations
func (mmListUserCart *CartRepositoryMock) ListUserCartAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmListUserCart.afterListUserCartCounter)
}</span>

// ListUserCartBeforeCounter returns a count of CartRepositoryMock.ListUserCart invocations
func (mmListUserCart *CartRepositoryMock) ListUserCartBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmListUserCart.beforeListUserCartCounter)
}</span>

// Calls returns a list of arguments used in each call to CartRepositoryMock.ListUserCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListUserCart *mCartRepositoryMockListUserCart) Calls() []*CartRepositoryMockListUserCartParams <span class="cov0" title="0">{
        mmListUserCart.mutex.RLock()

        argCopy := make([]*CartRepositoryMockListUserCartParams, len(mmListUserCart.callArgs))
        copy(argCopy, mmListUserCart.callArgs)

        mmListUserCart.mutex.RUnlock()

        return argCopy
}</span>

// MinimockListUserCartDone returns true if the count of the ListUserCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockListUserCartDone() bool <span class="cov6" title="8">{
        if m.ListUserCartMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov6" title="8">for _, e := range m.ListUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov6" title="8">return m.ListUserCartMock.invocationsDone()</span>
}

// MinimockListUserCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockListUserCartInspect() <span class="cov0" title="0">{
        for _, e := range m.ListUserCartMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to CartRepositoryMock.ListUserCart with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterListUserCartCounter := mm_atomic.LoadUint64(&amp;m.afterListUserCartCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.ListUserCartMock.defaultExpectation != nil &amp;&amp; afterListUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.ListUserCartMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to CartRepositoryMock.ListUserCart")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to CartRepositoryMock.ListUserCart with params: %#v", *m.ListUserCartMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcListUserCart != nil &amp;&amp; afterListUserCartCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to CartRepositoryMock.ListUserCart")
        }</span>

        <span class="cov0" title="0">if !m.ListUserCartMock.invocationsDone() &amp;&amp; afterListUserCartCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to CartRepositoryMock.ListUserCart but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.ListUserCartMock.expectedInvocations), afterListUserCartCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() <span class="cov10" title="23">{
        m.finishOnce.Do(func() </span><span class="cov6" title="8">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockAddItemToUserCartInspect()

                        m.MinimockClearUserCartInspect()

                        m.MinimockDeleteItemFromUserCartInspect()

                        m.MinimockListUserCartInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *CartRepositoryMock) minimockDone() bool <span class="cov6" title="8">{
        done := true
        return done &amp;&amp;
                m.MinimockAddItemToUserCartDone() &amp;&amp;
                m.MinimockClearUserCartDone() &amp;&amp;
                m.MinimockDeleteItemFromUserCartDone() &amp;&amp;
                m.MinimockListUserCartDone()
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/cart/internal/service.lomsClient -o loms_client_mock.go -n LomsClientMock -p mocks

import (
        "context"
        "route256/cart/pkg/loms"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
)

// LomsClientMock implements service.lomsClient
type LomsClientMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcCreateOrder          func(ctx context.Context, userID int64, items []loms.OrderItem) (i1 int64, err error)
        inspectFuncCreateOrder   func(ctx context.Context, userID int64, items []loms.OrderItem)
        afterCreateOrderCounter  uint64
        beforeCreateOrderCounter uint64
        CreateOrderMock          mLomsClientMockCreateOrder

        funcGetStockInfo          func(ctx context.Context, sku uint32) (u1 uint64, err error)
        inspectFuncGetStockInfo   func(ctx context.Context, sku uint32)
        afterGetStockInfoCounter  uint64
        beforeGetStockInfoCounter uint64
        GetStockInfoMock          mLomsClientMockGetStockInfo
}

// NewLomsClientMock returns a mock for service.lomsClient
func NewLomsClientMock(t minimock.Tester) *LomsClientMock <span class="cov7" title="9">{
        m := &amp;LomsClientMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov7" title="8">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov7" title="9">m.CreateOrderMock = mLomsClientMockCreateOrder{mock: m}
        m.CreateOrderMock.callArgs = []*LomsClientMockCreateOrderParams{}

        m.GetStockInfoMock = mLomsClientMockGetStockInfo{mock: m}
        m.GetStockInfoMock.callArgs = []*LomsClientMockGetStockInfoParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mLomsClientMockCreateOrder struct {
        optional           bool
        mock               *LomsClientMock
        defaultExpectation *LomsClientMockCreateOrderExpectation
        expectations       []*LomsClientMockCreateOrderExpectation

        callArgs []*LomsClientMockCreateOrderParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// LomsClientMockCreateOrderExpectation specifies expectation struct of the lomsClient.CreateOrder
type LomsClientMockCreateOrderExpectation struct {
        mock      *LomsClientMock
        params    *LomsClientMockCreateOrderParams
        paramPtrs *LomsClientMockCreateOrderParamPtrs
        results   *LomsClientMockCreateOrderResults
        Counter   uint64
}

// LomsClientMockCreateOrderParams contains parameters of the lomsClient.CreateOrder
type LomsClientMockCreateOrderParams struct {
        ctx    context.Context
        userID int64
        items  []loms.OrderItem
}

// LomsClientMockCreateOrderParamPtrs contains pointers to parameters of the lomsClient.CreateOrder
type LomsClientMockCreateOrderParamPtrs struct {
        ctx    *context.Context
        userID *int64
        items  *[]loms.OrderItem
}

// LomsClientMockCreateOrderResults contains results of the lomsClient.CreateOrder
type LomsClientMockCreateOrderResults struct {
        i1  int64
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrder *mLomsClientMockCreateOrder) Optional() *mLomsClientMockCreateOrder <span class="cov0" title="0">{
        mmCreateOrder.optional = true
        return mmCreateOrder
}</span>

// Expect sets up expected params for lomsClient.CreateOrder
func (mmCreateOrder *mLomsClientMockCreateOrder) Expect(ctx context.Context, userID int64, items []loms.OrderItem) *mLomsClientMockCreateOrder <span class="cov0" title="0">{
        if mmCreateOrder.mock.funcCreateOrder != nil </span><span class="cov0" title="0">{
                mmCreateOrder.mock.t.Fatalf("LomsClientMock.CreateOrder mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateOrder.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateOrder.defaultExpectation = &amp;LomsClientMockCreateOrderExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateOrder.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreateOrder.mock.t.Fatalf("LomsClientMock.CreateOrder mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmCreateOrder.defaultExpectation.params = &amp;LomsClientMockCreateOrderParams{ctx, userID, items}
        for _, e := range mmCreateOrder.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmCreateOrder</span>
}

// ExpectCtxParam1 sets up expected param ctx for lomsClient.CreateOrder
func (mmCreateOrder *mLomsClientMockCreateOrder) ExpectCtxParam1(ctx context.Context) *mLomsClientMockCreateOrder <span class="cov0" title="0">{
        if mmCreateOrder.mock.funcCreateOrder != nil </span><span class="cov0" title="0">{
                mmCreateOrder.mock.t.Fatalf("LomsClientMock.CreateOrder mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateOrder.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateOrder.defaultExpectation = &amp;LomsClientMockCreateOrderExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateOrder.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateOrder.mock.t.Fatalf("LomsClientMock.CreateOrder mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateOrder.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateOrder.defaultExpectation.paramPtrs = &amp;LomsClientMockCreateOrderParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateOrder.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmCreateOrder</span>
}

// ExpectUserIDParam2 sets up expected param userID for lomsClient.CreateOrder
func (mmCreateOrder *mLomsClientMockCreateOrder) ExpectUserIDParam2(userID int64) *mLomsClientMockCreateOrder <span class="cov0" title="0">{
        if mmCreateOrder.mock.funcCreateOrder != nil </span><span class="cov0" title="0">{
                mmCreateOrder.mock.t.Fatalf("LomsClientMock.CreateOrder mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateOrder.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateOrder.defaultExpectation = &amp;LomsClientMockCreateOrderExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateOrder.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateOrder.mock.t.Fatalf("LomsClientMock.CreateOrder mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateOrder.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateOrder.defaultExpectation.paramPtrs = &amp;LomsClientMockCreateOrderParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateOrder.defaultExpectation.paramPtrs.userID = &amp;userID

        return mmCreateOrder</span>
}

// ExpectItemsParam3 sets up expected param items for lomsClient.CreateOrder
func (mmCreateOrder *mLomsClientMockCreateOrder) ExpectItemsParam3(items []loms.OrderItem) *mLomsClientMockCreateOrder <span class="cov0" title="0">{
        if mmCreateOrder.mock.funcCreateOrder != nil </span><span class="cov0" title="0">{
                mmCreateOrder.mock.t.Fatalf("LomsClientMock.CreateOrder mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateOrder.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateOrder.defaultExpectation = &amp;LomsClientMockCreateOrderExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateOrder.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateOrder.mock.t.Fatalf("LomsClientMock.CreateOrder mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateOrder.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateOrder.defaultExpectation.paramPtrs = &amp;LomsClientMockCreateOrderParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateOrder.defaultExpectation.paramPtrs.items = &amp;items

        return mmCreateOrder</span>
}

// Inspect accepts an inspector function that has same arguments as the lomsClient.CreateOrder
func (mmCreateOrder *mLomsClientMockCreateOrder) Inspect(f func(ctx context.Context, userID int64, items []loms.OrderItem)) *mLomsClientMockCreateOrder <span class="cov0" title="0">{
        if mmCreateOrder.mock.inspectFuncCreateOrder != nil </span><span class="cov0" title="0">{
                mmCreateOrder.mock.t.Fatalf("Inspect function is already set for LomsClientMock.CreateOrder")
        }</span>

        <span class="cov0" title="0">mmCreateOrder.mock.inspectFuncCreateOrder = f

        return mmCreateOrder</span>
}

// Return sets up results that will be returned by lomsClient.CreateOrder
func (mmCreateOrder *mLomsClientMockCreateOrder) Return(i1 int64, err error) *LomsClientMock <span class="cov0" title="0">{
        if mmCreateOrder.mock.funcCreateOrder != nil </span><span class="cov0" title="0">{
                mmCreateOrder.mock.t.Fatalf("LomsClientMock.CreateOrder mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateOrder.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateOrder.defaultExpectation = &amp;LomsClientMockCreateOrderExpectation{mock: mmCreateOrder.mock}
        }</span>
        <span class="cov0" title="0">mmCreateOrder.defaultExpectation.results = &amp;LomsClientMockCreateOrderResults{i1, err}
        return mmCreateOrder.mock</span>
}

// Set uses given function f to mock the lomsClient.CreateOrder method
func (mmCreateOrder *mLomsClientMockCreateOrder) Set(f func(ctx context.Context, userID int64, items []loms.OrderItem) (i1 int64, err error)) *LomsClientMock <span class="cov0" title="0">{
        if mmCreateOrder.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the lomsClient.CreateOrder method")
        }</span>

        <span class="cov0" title="0">if len(mmCreateOrder.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the lomsClient.CreateOrder method")
        }</span>

        <span class="cov0" title="0">mmCreateOrder.mock.funcCreateOrder = f
        return mmCreateOrder.mock</span>
}

// When sets expectation for the lomsClient.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mLomsClientMockCreateOrder) When(ctx context.Context, userID int64, items []loms.OrderItem) *LomsClientMockCreateOrderExpectation <span class="cov0" title="0">{
        if mmCreateOrder.mock.funcCreateOrder != nil </span><span class="cov0" title="0">{
                mmCreateOrder.mock.t.Fatalf("LomsClientMock.CreateOrder mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;LomsClientMockCreateOrderExpectation{
                mock:   mmCreateOrder.mock,
                params: &amp;LomsClientMockCreateOrderParams{ctx, userID, items},
        }
        mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
        return expectation</span>
}

// Then sets up lomsClient.CreateOrder return parameters for the expectation previously defined by the When method
func (e *LomsClientMockCreateOrderExpectation) Then(i1 int64, err error) *LomsClientMock <span class="cov0" title="0">{
        e.results = &amp;LomsClientMockCreateOrderResults{i1, err}
        return e.mock
}</span>

// Times sets number of times lomsClient.CreateOrder should be invoked
func (mmCreateOrder *mLomsClientMockCreateOrder) Times(n uint64) *mLomsClientMockCreateOrder <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreateOrder.mock.t.Fatalf("Times of LomsClientMock.CreateOrder mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreateOrder.expectedInvocations, n)
        return mmCreateOrder</span>
}

func (mmCreateOrder *mLomsClientMockCreateOrder) invocationsDone() bool <span class="cov7" title="9">{
        if len(mmCreateOrder.expectations) == 0 &amp;&amp; mmCreateOrder.defaultExpectation == nil &amp;&amp; mmCreateOrder.mock.funcCreateOrder == nil </span><span class="cov7" title="9">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreateOrder.mock.afterCreateOrderCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreateOrder.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// CreateOrder implements service.lomsClient
func (mmCreateOrder *LomsClientMock) CreateOrder(ctx context.Context, userID int64, items []loms.OrderItem) (i1 int64, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmCreateOrder.beforeCreateOrderCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreateOrder.afterCreateOrderCounter, 1)

        if mmCreateOrder.inspectFuncCreateOrder != nil </span><span class="cov0" title="0">{
                mmCreateOrder.inspectFuncCreateOrder(ctx, userID, items)
        }</span>

        <span class="cov0" title="0">mm_params := LomsClientMockCreateOrderParams{ctx, userID, items}

        // Record call args
        mmCreateOrder.CreateOrderMock.mutex.Lock()
        mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &amp;mm_params)
        mmCreateOrder.CreateOrderMock.mutex.Unlock()

        for _, e := range mmCreateOrder.CreateOrderMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.i1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmCreateOrder.CreateOrderMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
                mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
                mm_want_ptrs := mmCreateOrder.CreateOrderMock.defaultExpectation.paramPtrs

                mm_got := LomsClientMockCreateOrderParams{ctx, userID, items}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreateOrder.t.Errorf("LomsClientMock.CreateOrder got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.userID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) </span><span class="cov0" title="0">{
                                mmCreateOrder.t.Errorf("LomsClientMock.CreateOrder got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.items != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.items, mm_got.items) </span><span class="cov0" title="0">{
                                mmCreateOrder.t.Errorf("LomsClientMock.CreateOrder got unexpected parameter items, want: %#v, got: %#v%s\n", *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreateOrder.t.Errorf("LomsClientMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreateOrder.t.Fatal("No results are set for the LomsClientMock.CreateOrder")
                }</span>
                <span class="cov0" title="0">return (*mm_results).i1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreateOrder.funcCreateOrder != nil </span><span class="cov0" title="0">{
                return mmCreateOrder.funcCreateOrder(ctx, userID, items)
        }</span>
        <span class="cov0" title="0">mmCreateOrder.t.Fatalf("Unexpected call to LomsClientMock.CreateOrder. %v %v %v", ctx, userID, items)
        return</span>
}

// CreateOrderAfterCounter returns a count of finished LomsClientMock.CreateOrder invocations
func (mmCreateOrder *LomsClientMock) CreateOrderAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateOrder.afterCreateOrderCounter)
}</span>

// CreateOrderBeforeCounter returns a count of LomsClientMock.CreateOrder invocations
func (mmCreateOrder *LomsClientMock) CreateOrderBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateOrder.beforeCreateOrderCounter)
}</span>

// Calls returns a list of arguments used in each call to LomsClientMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mLomsClientMockCreateOrder) Calls() []*LomsClientMockCreateOrderParams <span class="cov0" title="0">{
        mmCreateOrder.mutex.RLock()

        argCopy := make([]*LomsClientMockCreateOrderParams, len(mmCreateOrder.callArgs))
        copy(argCopy, mmCreateOrder.callArgs)

        mmCreateOrder.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *LomsClientMock) MinimockCreateOrderDone() bool <span class="cov7" title="9">{
        if m.CreateOrderMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov7" title="9">for _, e := range m.CreateOrderMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov7" title="9">return m.CreateOrderMock.invocationsDone()</span>
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *LomsClientMock) MinimockCreateOrderInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateOrderMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to LomsClientMock.CreateOrder with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateOrderCounter := mm_atomic.LoadUint64(&amp;m.afterCreateOrderCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateOrderMock.defaultExpectation != nil &amp;&amp; afterCreateOrderCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateOrderMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to LomsClientMock.CreateOrder")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to LomsClientMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreateOrder != nil &amp;&amp; afterCreateOrderCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to LomsClientMock.CreateOrder")
        }</span>

        <span class="cov0" title="0">if !m.CreateOrderMock.invocationsDone() &amp;&amp; afterCreateOrderCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to LomsClientMock.CreateOrder but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateOrderMock.expectedInvocations), afterCreateOrderCounter)
        }</span>
}

type mLomsClientMockGetStockInfo struct {
        optional           bool
        mock               *LomsClientMock
        defaultExpectation *LomsClientMockGetStockInfoExpectation
        expectations       []*LomsClientMockGetStockInfoExpectation

        callArgs []*LomsClientMockGetStockInfoParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// LomsClientMockGetStockInfoExpectation specifies expectation struct of the lomsClient.GetStockInfo
type LomsClientMockGetStockInfoExpectation struct {
        mock      *LomsClientMock
        params    *LomsClientMockGetStockInfoParams
        paramPtrs *LomsClientMockGetStockInfoParamPtrs
        results   *LomsClientMockGetStockInfoResults
        Counter   uint64
}

// LomsClientMockGetStockInfoParams contains parameters of the lomsClient.GetStockInfo
type LomsClientMockGetStockInfoParams struct {
        ctx context.Context
        sku uint32
}

// LomsClientMockGetStockInfoParamPtrs contains pointers to parameters of the lomsClient.GetStockInfo
type LomsClientMockGetStockInfoParamPtrs struct {
        ctx *context.Context
        sku *uint32
}

// LomsClientMockGetStockInfoResults contains results of the lomsClient.GetStockInfo
type LomsClientMockGetStockInfoResults struct {
        u1  uint64
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStockInfo *mLomsClientMockGetStockInfo) Optional() *mLomsClientMockGetStockInfo <span class="cov0" title="0">{
        mmGetStockInfo.optional = true
        return mmGetStockInfo
}</span>

// Expect sets up expected params for lomsClient.GetStockInfo
func (mmGetStockInfo *mLomsClientMockGetStockInfo) Expect(ctx context.Context, sku uint32) *mLomsClientMockGetStockInfo <span class="cov0" title="0">{
        if mmGetStockInfo.mock.funcGetStockInfo != nil </span><span class="cov0" title="0">{
                mmGetStockInfo.mock.t.Fatalf("LomsClientMock.GetStockInfo mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetStockInfo.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetStockInfo.defaultExpectation = &amp;LomsClientMockGetStockInfoExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetStockInfo.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetStockInfo.mock.t.Fatalf("LomsClientMock.GetStockInfo mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetStockInfo.defaultExpectation.params = &amp;LomsClientMockGetStockInfoParams{ctx, sku}
        for _, e := range mmGetStockInfo.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetStockInfo.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetStockInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStockInfo.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetStockInfo</span>
}

// ExpectCtxParam1 sets up expected param ctx for lomsClient.GetStockInfo
func (mmGetStockInfo *mLomsClientMockGetStockInfo) ExpectCtxParam1(ctx context.Context) *mLomsClientMockGetStockInfo <span class="cov0" title="0">{
        if mmGetStockInfo.mock.funcGetStockInfo != nil </span><span class="cov0" title="0">{
                mmGetStockInfo.mock.t.Fatalf("LomsClientMock.GetStockInfo mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetStockInfo.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetStockInfo.defaultExpectation = &amp;LomsClientMockGetStockInfoExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetStockInfo.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetStockInfo.mock.t.Fatalf("LomsClientMock.GetStockInfo mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetStockInfo.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetStockInfo.defaultExpectation.paramPtrs = &amp;LomsClientMockGetStockInfoParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetStockInfo.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmGetStockInfo</span>
}

// ExpectSkuParam2 sets up expected param sku for lomsClient.GetStockInfo
func (mmGetStockInfo *mLomsClientMockGetStockInfo) ExpectSkuParam2(sku uint32) *mLomsClientMockGetStockInfo <span class="cov0" title="0">{
        if mmGetStockInfo.mock.funcGetStockInfo != nil </span><span class="cov0" title="0">{
                mmGetStockInfo.mock.t.Fatalf("LomsClientMock.GetStockInfo mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetStockInfo.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetStockInfo.defaultExpectation = &amp;LomsClientMockGetStockInfoExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetStockInfo.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetStockInfo.mock.t.Fatalf("LomsClientMock.GetStockInfo mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetStockInfo.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetStockInfo.defaultExpectation.paramPtrs = &amp;LomsClientMockGetStockInfoParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetStockInfo.defaultExpectation.paramPtrs.sku = &amp;sku

        return mmGetStockInfo</span>
}

// Inspect accepts an inspector function that has same arguments as the lomsClient.GetStockInfo
func (mmGetStockInfo *mLomsClientMockGetStockInfo) Inspect(f func(ctx context.Context, sku uint32)) *mLomsClientMockGetStockInfo <span class="cov0" title="0">{
        if mmGetStockInfo.mock.inspectFuncGetStockInfo != nil </span><span class="cov0" title="0">{
                mmGetStockInfo.mock.t.Fatalf("Inspect function is already set for LomsClientMock.GetStockInfo")
        }</span>

        <span class="cov0" title="0">mmGetStockInfo.mock.inspectFuncGetStockInfo = f

        return mmGetStockInfo</span>
}

// Return sets up results that will be returned by lomsClient.GetStockInfo
func (mmGetStockInfo *mLomsClientMockGetStockInfo) Return(u1 uint64, err error) *LomsClientMock <span class="cov0" title="0">{
        if mmGetStockInfo.mock.funcGetStockInfo != nil </span><span class="cov0" title="0">{
                mmGetStockInfo.mock.t.Fatalf("LomsClientMock.GetStockInfo mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetStockInfo.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetStockInfo.defaultExpectation = &amp;LomsClientMockGetStockInfoExpectation{mock: mmGetStockInfo.mock}
        }</span>
        <span class="cov0" title="0">mmGetStockInfo.defaultExpectation.results = &amp;LomsClientMockGetStockInfoResults{u1, err}
        return mmGetStockInfo.mock</span>
}

// Set uses given function f to mock the lomsClient.GetStockInfo method
func (mmGetStockInfo *mLomsClientMockGetStockInfo) Set(f func(ctx context.Context, sku uint32) (u1 uint64, err error)) *LomsClientMock <span class="cov1" title="1">{
        if mmGetStockInfo.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetStockInfo.mock.t.Fatalf("Default expectation is already set for the lomsClient.GetStockInfo method")
        }</span>

        <span class="cov1" title="1">if len(mmGetStockInfo.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetStockInfo.mock.t.Fatalf("Some expectations are already set for the lomsClient.GetStockInfo method")
        }</span>

        <span class="cov1" title="1">mmGetStockInfo.mock.funcGetStockInfo = f
        return mmGetStockInfo.mock</span>
}

// When sets expectation for the lomsClient.GetStockInfo which will trigger the result defined by the following
// Then helper
func (mmGetStockInfo *mLomsClientMockGetStockInfo) When(ctx context.Context, sku uint32) *LomsClientMockGetStockInfoExpectation <span class="cov0" title="0">{
        if mmGetStockInfo.mock.funcGetStockInfo != nil </span><span class="cov0" title="0">{
                mmGetStockInfo.mock.t.Fatalf("LomsClientMock.GetStockInfo mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;LomsClientMockGetStockInfoExpectation{
                mock:   mmGetStockInfo.mock,
                params: &amp;LomsClientMockGetStockInfoParams{ctx, sku},
        }
        mmGetStockInfo.expectations = append(mmGetStockInfo.expectations, expectation)
        return expectation</span>
}

// Then sets up lomsClient.GetStockInfo return parameters for the expectation previously defined by the When method
func (e *LomsClientMockGetStockInfoExpectation) Then(u1 uint64, err error) *LomsClientMock <span class="cov0" title="0">{
        e.results = &amp;LomsClientMockGetStockInfoResults{u1, err}
        return e.mock
}</span>

// Times sets number of times lomsClient.GetStockInfo should be invoked
func (mmGetStockInfo *mLomsClientMockGetStockInfo) Times(n uint64) *mLomsClientMockGetStockInfo <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetStockInfo.mock.t.Fatalf("Times of LomsClientMock.GetStockInfo mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetStockInfo.expectedInvocations, n)
        return mmGetStockInfo</span>
}

func (mmGetStockInfo *mLomsClientMockGetStockInfo) invocationsDone() bool <span class="cov7" title="9">{
        if len(mmGetStockInfo.expectations) == 0 &amp;&amp; mmGetStockInfo.defaultExpectation == nil &amp;&amp; mmGetStockInfo.mock.funcGetStockInfo == nil </span><span class="cov7" title="8">{
                return true
        }</span>

        <span class="cov1" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetStockInfo.mock.afterGetStockInfoCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetStockInfo.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetStockInfo implements service.lomsClient
func (mmGetStockInfo *LomsClientMock) GetStockInfo(ctx context.Context, sku uint32) (u1 uint64, err error) <span class="cov1" title="1">{
        mm_atomic.AddUint64(&amp;mmGetStockInfo.beforeGetStockInfoCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetStockInfo.afterGetStockInfoCounter, 1)

        if mmGetStockInfo.inspectFuncGetStockInfo != nil </span><span class="cov0" title="0">{
                mmGetStockInfo.inspectFuncGetStockInfo(ctx, sku)
        }</span>

        <span class="cov1" title="1">mm_params := LomsClientMockGetStockInfoParams{ctx, sku}

        // Record call args
        mmGetStockInfo.GetStockInfoMock.mutex.Lock()
        mmGetStockInfo.GetStockInfoMock.callArgs = append(mmGetStockInfo.GetStockInfoMock.callArgs, &amp;mm_params)
        mmGetStockInfo.GetStockInfoMock.mutex.Unlock()

        for _, e := range mmGetStockInfo.GetStockInfoMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.u1, e.results.err
                }</span>
        }

        <span class="cov1" title="1">if mmGetStockInfo.GetStockInfoMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGetStockInfo.GetStockInfoMock.defaultExpectation.Counter, 1)
                mm_want := mmGetStockInfo.GetStockInfoMock.defaultExpectation.params
                mm_want_ptrs := mmGetStockInfo.GetStockInfoMock.defaultExpectation.paramPtrs

                mm_got := LomsClientMockGetStockInfoParams{ctx, sku}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetStockInfo.t.Errorf("LomsClientMock.GetStockInfo got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.sku != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) </span><span class="cov0" title="0">{
                                mmGetStockInfo.t.Errorf("LomsClientMock.GetStockInfo got unexpected parameter sku, want: %#v, got: %#v%s\n", *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetStockInfo.t.Errorf("LomsClientMock.GetStockInfo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGetStockInfo.GetStockInfoMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetStockInfo.t.Fatal("No results are set for the LomsClientMock.GetStockInfo")
                }</span>
                <span class="cov0" title="0">return (*mm_results).u1, (*mm_results).err</span>
        }
        <span class="cov1" title="1">if mmGetStockInfo.funcGetStockInfo != nil </span><span class="cov1" title="1">{
                return mmGetStockInfo.funcGetStockInfo(ctx, sku)
        }</span>
        <span class="cov0" title="0">mmGetStockInfo.t.Fatalf("Unexpected call to LomsClientMock.GetStockInfo. %v %v", ctx, sku)
        return</span>
}

// GetStockInfoAfterCounter returns a count of finished LomsClientMock.GetStockInfo invocations
func (mmGetStockInfo *LomsClientMock) GetStockInfoAfterCounter() uint64 <span class="cov1" title="1">{
        return mm_atomic.LoadUint64(&amp;mmGetStockInfo.afterGetStockInfoCounter)
}</span>

// GetStockInfoBeforeCounter returns a count of LomsClientMock.GetStockInfo invocations
func (mmGetStockInfo *LomsClientMock) GetStockInfoBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetStockInfo.beforeGetStockInfoCounter)
}</span>

// Calls returns a list of arguments used in each call to LomsClientMock.GetStockInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStockInfo *mLomsClientMockGetStockInfo) Calls() []*LomsClientMockGetStockInfoParams <span class="cov0" title="0">{
        mmGetStockInfo.mutex.RLock()

        argCopy := make([]*LomsClientMockGetStockInfoParams, len(mmGetStockInfo.callArgs))
        copy(argCopy, mmGetStockInfo.callArgs)

        mmGetStockInfo.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetStockInfoDone returns true if the count of the GetStockInfo invocations corresponds
// the number of defined expectations
func (m *LomsClientMock) MinimockGetStockInfoDone() bool <span class="cov7" title="9">{
        if m.GetStockInfoMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov7" title="9">for _, e := range m.GetStockInfoMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov7" title="9">return m.GetStockInfoMock.invocationsDone()</span>
}

// MinimockGetStockInfoInspect logs each unmet expectation
func (m *LomsClientMock) MinimockGetStockInfoInspect() <span class="cov0" title="0">{
        for _, e := range m.GetStockInfoMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to LomsClientMock.GetStockInfo with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetStockInfoCounter := mm_atomic.LoadUint64(&amp;m.afterGetStockInfoCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetStockInfoMock.defaultExpectation != nil &amp;&amp; afterGetStockInfoCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetStockInfoMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to LomsClientMock.GetStockInfo")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to LomsClientMock.GetStockInfo with params: %#v", *m.GetStockInfoMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetStockInfo != nil &amp;&amp; afterGetStockInfoCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to LomsClientMock.GetStockInfo")
        }</span>

        <span class="cov0" title="0">if !m.GetStockInfoMock.invocationsDone() &amp;&amp; afterGetStockInfoCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to LomsClientMock.GetStockInfo but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetStockInfoMock.expectedInvocations), afterGetStockInfoCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LomsClientMock) MinimockFinish() <span class="cov10" title="20">{
        m.finishOnce.Do(func() </span><span class="cov7" title="9">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockCreateOrderInspect()

                        m.MinimockGetStockInfoInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LomsClientMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *LomsClientMock) minimockDone() bool <span class="cov7" title="9">{
        done := true
        return done &amp;&amp;
                m.MinimockCreateOrderDone() &amp;&amp;
                m.MinimockGetStockInfoDone()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/cart/internal/service.productClient -o product_client_mock.go -n ProductClientMock -p mocks

import (
        "context"
        "route256/cart/pkg/product"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
)

// ProductClientMock implements service.productClient
type ProductClientMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcGetProduct          func(ctx context.Context, skuID uint32) (pp1 *product.Product, err error)
        inspectFuncGetProduct   func(ctx context.Context, skuID uint32)
        afterGetProductCounter  uint64
        beforeGetProductCounter uint64
        GetProductMock          mProductClientMockGetProduct
}

// NewProductClientMock returns a mock for service.productClient
func NewProductClientMock(t minimock.Tester) *ProductClientMock <span class="cov7" title="8">{
        m := &amp;ProductClientMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov7" title="8">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov7" title="8">m.GetProductMock = mProductClientMockGetProduct{mock: m}
        m.GetProductMock.callArgs = []*ProductClientMockGetProductParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mProductClientMockGetProduct struct {
        optional           bool
        mock               *ProductClientMock
        defaultExpectation *ProductClientMockGetProductExpectation
        expectations       []*ProductClientMockGetProductExpectation

        callArgs []*ProductClientMockGetProductParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// ProductClientMockGetProductExpectation specifies expectation struct of the productClient.GetProduct
type ProductClientMockGetProductExpectation struct {
        mock      *ProductClientMock
        params    *ProductClientMockGetProductParams
        paramPtrs *ProductClientMockGetProductParamPtrs
        results   *ProductClientMockGetProductResults
        Counter   uint64
}

// ProductClientMockGetProductParams contains parameters of the productClient.GetProduct
type ProductClientMockGetProductParams struct {
        ctx   context.Context
        skuID uint32
}

// ProductClientMockGetProductParamPtrs contains pointers to parameters of the productClient.GetProduct
type ProductClientMockGetProductParamPtrs struct {
        ctx   *context.Context
        skuID *uint32
}

// ProductClientMockGetProductResults contains results of the productClient.GetProduct
type ProductClientMockGetProductResults struct {
        pp1 *product.Product
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetProduct *mProductClientMockGetProduct) Optional() *mProductClientMockGetProduct <span class="cov0" title="0">{
        mmGetProduct.optional = true
        return mmGetProduct
}</span>

// Expect sets up expected params for productClient.GetProduct
func (mmGetProduct *mProductClientMockGetProduct) Expect(ctx context.Context, skuID uint32) *mProductClientMockGetProduct <span class="cov0" title="0">{
        if mmGetProduct.mock.funcGetProduct != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetProduct.defaultExpectation = &amp;ProductClientMockGetProductExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetProduct.defaultExpectation.params = &amp;ProductClientMockGetProductParams{ctx, skuID}
        for _, e := range mmGetProduct.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetProduct.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProduct.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetProduct</span>
}

// ExpectCtxParam1 sets up expected param ctx for productClient.GetProduct
func (mmGetProduct *mProductClientMockGetProduct) ExpectCtxParam1(ctx context.Context) *mProductClientMockGetProduct <span class="cov0" title="0">{
        if mmGetProduct.mock.funcGetProduct != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetProduct.defaultExpectation = &amp;ProductClientMockGetProductExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetProduct.defaultExpectation.paramPtrs = &amp;ProductClientMockGetProductParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetProduct.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmGetProduct</span>
}

// ExpectSkuIDParam2 sets up expected param skuID for productClient.GetProduct
func (mmGetProduct *mProductClientMockGetProduct) ExpectSkuIDParam2(skuID uint32) *mProductClientMockGetProduct <span class="cov0" title="0">{
        if mmGetProduct.mock.funcGetProduct != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetProduct.defaultExpectation = &amp;ProductClientMockGetProductExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetProduct.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetProduct.defaultExpectation.paramPtrs = &amp;ProductClientMockGetProductParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetProduct.defaultExpectation.paramPtrs.skuID = &amp;skuID

        return mmGetProduct</span>
}

// Inspect accepts an inspector function that has same arguments as the productClient.GetProduct
func (mmGetProduct *mProductClientMockGetProduct) Inspect(f func(ctx context.Context, skuID uint32)) *mProductClientMockGetProduct <span class="cov0" title="0">{
        if mmGetProduct.mock.inspectFuncGetProduct != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("Inspect function is already set for ProductClientMock.GetProduct")
        }</span>

        <span class="cov0" title="0">mmGetProduct.mock.inspectFuncGetProduct = f

        return mmGetProduct</span>
}

// Return sets up results that will be returned by productClient.GetProduct
func (mmGetProduct *mProductClientMockGetProduct) Return(pp1 *product.Product, err error) *ProductClientMock <span class="cov4" title="3">{
        if mmGetProduct.mock.funcGetProduct != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by Set")
        }</span>

        <span class="cov4" title="3">if mmGetProduct.defaultExpectation == nil </span><span class="cov4" title="3">{
                mmGetProduct.defaultExpectation = &amp;ProductClientMockGetProductExpectation{mock: mmGetProduct.mock}
        }</span>
        <span class="cov4" title="3">mmGetProduct.defaultExpectation.results = &amp;ProductClientMockGetProductResults{pp1, err}
        return mmGetProduct.mock</span>
}

// Set uses given function f to mock the productClient.GetProduct method
func (mmGetProduct *mProductClientMockGetProduct) Set(f func(ctx context.Context, skuID uint32) (pp1 *product.Product, err error)) *ProductClientMock <span class="cov3" title="2">{
        if mmGetProduct.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("Default expectation is already set for the productClient.GetProduct method")
        }</span>

        <span class="cov3" title="2">if len(mmGetProduct.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("Some expectations are already set for the productClient.GetProduct method")
        }</span>

        <span class="cov3" title="2">mmGetProduct.mock.funcGetProduct = f
        return mmGetProduct.mock</span>
}

// When sets expectation for the productClient.GetProduct which will trigger the result defined by the following
// Then helper
func (mmGetProduct *mProductClientMockGetProduct) When(ctx context.Context, skuID uint32) *ProductClientMockGetProductExpectation <span class="cov0" title="0">{
        if mmGetProduct.mock.funcGetProduct != nil </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("ProductClientMock.GetProduct mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;ProductClientMockGetProductExpectation{
                mock:   mmGetProduct.mock,
                params: &amp;ProductClientMockGetProductParams{ctx, skuID},
        }
        mmGetProduct.expectations = append(mmGetProduct.expectations, expectation)
        return expectation</span>
}

// Then sets up productClient.GetProduct return parameters for the expectation previously defined by the When method
func (e *ProductClientMockGetProductExpectation) Then(pp1 *product.Product, err error) *ProductClientMock <span class="cov0" title="0">{
        e.results = &amp;ProductClientMockGetProductResults{pp1, err}
        return e.mock
}</span>

// Times sets number of times productClient.GetProduct should be invoked
func (mmGetProduct *mProductClientMockGetProduct) Times(n uint64) *mProductClientMockGetProduct <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetProduct.mock.t.Fatalf("Times of ProductClientMock.GetProduct mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetProduct.expectedInvocations, n)
        return mmGetProduct</span>
}

func (mmGetProduct *mProductClientMockGetProduct) invocationsDone() bool <span class="cov7" title="8">{
        if len(mmGetProduct.expectations) == 0 &amp;&amp; mmGetProduct.defaultExpectation == nil &amp;&amp; mmGetProduct.mock.funcGetProduct == nil </span><span class="cov4" title="3">{
                return true
        }</span>

        <span class="cov5" title="5">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetProduct.mock.afterGetProductCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetProduct.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetProduct implements service.productClient
func (mmGetProduct *ProductClientMock) GetProduct(ctx context.Context, skuID uint32) (pp1 *product.Product, err error) <span class="cov6" title="6">{
        mm_atomic.AddUint64(&amp;mmGetProduct.beforeGetProductCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetProduct.afterGetProductCounter, 1)

        if mmGetProduct.inspectFuncGetProduct != nil </span><span class="cov0" title="0">{
                mmGetProduct.inspectFuncGetProduct(ctx, skuID)
        }</span>

        <span class="cov6" title="6">mm_params := ProductClientMockGetProductParams{ctx, skuID}

        // Record call args
        mmGetProduct.GetProductMock.mutex.Lock()
        mmGetProduct.GetProductMock.callArgs = append(mmGetProduct.GetProductMock.callArgs, &amp;mm_params)
        mmGetProduct.GetProductMock.mutex.Unlock()

        for _, e := range mmGetProduct.GetProductMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.pp1, e.results.err
                }</span>
        }

        <span class="cov6" title="6">if mmGetProduct.GetProductMock.defaultExpectation != nil </span><span class="cov4" title="3">{
                mm_atomic.AddUint64(&amp;mmGetProduct.GetProductMock.defaultExpectation.Counter, 1)
                mm_want := mmGetProduct.GetProductMock.defaultExpectation.params
                mm_want_ptrs := mmGetProduct.GetProductMock.defaultExpectation.paramPtrs

                mm_got := ProductClientMockGetProductParams{ctx, skuID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetProduct.t.Errorf("ProductClientMock.GetProduct got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.skuID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) </span><span class="cov0" title="0">{
                                mmGetProduct.t.Errorf("ProductClientMock.GetProduct got unexpected parameter skuID, want: %#v, got: %#v%s\n", *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
                        }</span>

                } else<span class="cov4" title="3"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetProduct.t.Errorf("ProductClientMock.GetProduct got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov4" title="3">mm_results := mmGetProduct.GetProductMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetProduct.t.Fatal("No results are set for the ProductClientMock.GetProduct")
                }</span>
                <span class="cov4" title="3">return (*mm_results).pp1, (*mm_results).err</span>
        }
        <span class="cov4" title="3">if mmGetProduct.funcGetProduct != nil </span><span class="cov4" title="3">{
                return mmGetProduct.funcGetProduct(ctx, skuID)
        }</span>
        <span class="cov0" title="0">mmGetProduct.t.Fatalf("Unexpected call to ProductClientMock.GetProduct. %v %v", ctx, skuID)
        return</span>
}

// GetProductAfterCounter returns a count of finished ProductClientMock.GetProduct invocations
func (mmGetProduct *ProductClientMock) GetProductAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetProduct.afterGetProductCounter)
}</span>

// GetProductBeforeCounter returns a count of ProductClientMock.GetProduct invocations
func (mmGetProduct *ProductClientMock) GetProductBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetProduct.beforeGetProductCounter)
}</span>

// Calls returns a list of arguments used in each call to ProductClientMock.GetProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProduct *mProductClientMockGetProduct) Calls() []*ProductClientMockGetProductParams <span class="cov0" title="0">{
        mmGetProduct.mutex.RLock()

        argCopy := make([]*ProductClientMockGetProductParams, len(mmGetProduct.callArgs))
        copy(argCopy, mmGetProduct.callArgs)

        mmGetProduct.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetProductDone returns true if the count of the GetProduct invocations corresponds
// the number of defined expectations
func (m *ProductClientMock) MinimockGetProductDone() bool <span class="cov7" title="8">{
        if m.GetProductMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov7" title="8">for _, e := range m.GetProductMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov7" title="8">return m.GetProductMock.invocationsDone()</span>
}

// MinimockGetProductInspect logs each unmet expectation
func (m *ProductClientMock) MinimockGetProductInspect() <span class="cov0" title="0">{
        for _, e := range m.GetProductMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ProductClientMock.GetProduct with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetProductCounter := mm_atomic.LoadUint64(&amp;m.afterGetProductCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetProductMock.defaultExpectation != nil &amp;&amp; afterGetProductCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetProductMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ProductClientMock.GetProduct")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to ProductClientMock.GetProduct with params: %#v", *m.GetProductMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetProduct != nil &amp;&amp; afterGetProductCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to ProductClientMock.GetProduct")
        }</span>

        <span class="cov0" title="0">if !m.GetProductMock.invocationsDone() &amp;&amp; afterGetProductCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ProductClientMock.GetProduct but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetProductMock.expectedInvocations), afterGetProductCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProductClientMock) MinimockFinish() <span class="cov10" title="22">{
        m.finishOnce.Do(func() </span><span class="cov7" title="8">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockGetProductInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProductClientMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *ProductClientMock) minimockDone() bool <span class="cov7" title="8">{
        done := true
        return done &amp;&amp;
                m.MinimockGetProductDone()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package service

import (
        "context"
        "fmt"
        "sort"
        "sync"

        "route256/cart/internal/models"
        "route256/cart/pkg/errgroup"
        "route256/cart/pkg/loms"
        "route256/cart/pkg/product"
)

const countGoRoutines = 10

//go:generate minimock -i cartRepository -o ./mocks/ -s _mock.go
//go:generate minimock -i productClient -o ./mocks/ -s _mock.go
//go:generate minimock -i lomsClient -o ./mocks/ -s _mock.go
type cartRepository interface {
        AddItemToUserCart(ctx context.Context, cart models.CartRequest) error
        DeleteItemFromUserCart(ctx context.Context, userID, skuID int64) error
        ClearUserCart(ctx context.Context, userID int64) error
        ListUserCart(ctx context.Context, userID int64) ([]models.CartItem, error)
}

type productClient interface {
        GetProduct(ctx context.Context, skuID uint32) (*product.Product, error)
}

type lomsClient interface {
        CreateOrder(ctx context.Context, userID int64, items []loms.OrderItem) (int64, error)
        GetStockInfo(ctx context.Context, sku uint32) (uint64, error)
}

type Service struct {
        repo          cartRepository
        productClient productClient
        lomsClient    lomsClient
}

func NewService(repo cartRepository, productClient productClient, lomsClient lomsClient) *Service <span class="cov10" title="8">{
        return &amp;Service{repo: repo, productClient: productClient, lomsClient: lomsClient}
}</span>

func (s *Service) CreateOrder(ctx context.Context, userID int64) (int64, error) <span class="cov0" title="0">{
        items, err := s.repo.ListUserCart(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to list user cart: %w", err)
        }</span>

        <span class="cov0" title="0">stockInfo := make([]models.CartRequest, len(items))
        for i, item := range items </span><span class="cov0" title="0">{
                count, err := s.lomsClient.GetStockInfo(ctx, uint32(item.SkuID))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to get stock info: %w", err)
                }</span>

                <span class="cov0" title="0">stockInfo[i].Count = uint16(count)
                if stockInfo[i].Count &lt; item.Count || stockInfo[i].Count == 0 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("stock is not enough")
                }</span>

                <span class="cov0" title="0">stockInfo[i].SkuID = item.SkuID
                stockInfo[i].UserID = userID</span>
        }

        <span class="cov0" title="0">return s.lomsClient.CreateOrder(ctx, userID, models.CartRequestToCartOrder(stockInfo))</span>
}

func (s *Service) AddItemToUserCart(ctx context.Context, cart models.CartRequest) error <span class="cov5" title="3">{
        checkProduct, err := s.productClient.GetProduct(ctx, uint32(cart.SkuID))
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get product: %w", err)
        }</span>

        <span class="cov4" title="2">if checkProduct == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("product not found")
        }</span>

        <span class="cov1" title="1">count, err := s.lomsClient.GetStockInfo(ctx, uint32(cart.SkuID))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get stock info: %w", err)
        }</span>

        <span class="cov1" title="1">if uint16(count) &lt; cart.Count || count == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("stock is not enough")
        }</span>

        <span class="cov1" title="1">return s.repo.AddItemToUserCart(ctx, cart)</span>
}

func (s *Service) DeleteItemFromUserCart(ctx context.Context, userID, skuID int64) error <span class="cov1" title="1">{
        return s.repo.DeleteItemFromUserCart(ctx, userID, skuID)
}</span>

func (s *Service) ClearUserCart(ctx context.Context, userID int64) error <span class="cov1" title="1">{
        return s.repo.ClearUserCart(ctx, userID)
}</span>

func (s *Service) ListUserCart(ctx context.Context, userID int64) ([]models.CartItem, uint32, error) <span class="cov5" title="3">{
        items, err := s.repo.ListUserCart(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("failed to list cart: %w", err)
        }</span>

        <span class="cov4" title="2">var (
                cartItems  = make([]models.CartItem, len(items))
                totalPrice uint32
                mu         sync.Mutex
                g          = errgroup.NewGroup(countGoRoutines)
        )

        for i, item := range items </span><span class="cov5" title="3">{
                g.Go(func() error </span><span class="cov5" title="3">{
                        p, err := s.productClient.GetProduct(ctx, uint32(item.SkuID))
                        if err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to get product: %w", err)
                        }</span>
                        <span class="cov4" title="2">if p == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov4" title="2">mu.Lock()
                        cartItems[i] = models.CartItem{
                                SkuID: item.SkuID,
                                Name:  p.Name,
                                Count: item.Count,
                                Price: p.Price,
                        }
                        totalPrice += p.Price * uint32(item.Count)
                        mu.Unlock()
                        return nil</span>
                })
        }

        <span class="cov4" title="2">if err := g.Wait(); err != nil </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("failed to get products: %w", err)
        }</span>

        <span class="cov1" title="1">sort.Slice(cartItems, func(i, j int) bool </span><span class="cov1" title="1">{
                return cartItems[i].SkuID &lt; cartItems[j].SkuID
        }</span>)

        <span class="cov1" title="1">return cartItems, totalPrice, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package errgroup

import (
        "sync"
)

type Group struct {
        wg      sync.WaitGroup
        err     error
        errOnce sync.Once
        sem     chan struct{}
}

func NewGroup(limit int) *Group <span class="cov7" title="3">{
        return &amp;Group{
                sem: make(chan struct{}, limit),
        }
}</span>

func (g *Group) done() <span class="cov10" title="5">{
        &lt;-g.sem
        g.wg.Done()
}</span>

func (g *Group) Go(f func() error) <span class="cov10" title="5">{
        g.sem &lt;- struct{}{}
        g.wg.Add(1)
        go func() </span><span class="cov10" title="5">{
                defer g.done()
                if err := f(); err != nil </span><span class="cov1" title="1">{
                        g.errOnce.Do(func() </span><span class="cov1" title="1">{
                                g.err = err
                        }</span>)
                }
        }()
}

func (g *Group) Wait() error <span class="cov7" title="3">{
        g.wg.Wait()

        return g.err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package loms

import (
        "route256/cart/proto"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

type Client struct {
        host       string
        dialOption grpc.DialOption
        client     proto.LomsServiceClient
        conn       *grpc.ClientConn
}

func NewClient(host string) *Client <span class="cov0" title="0">{
        return &amp;Client{
                host:       host,
                dialOption: grpc.WithTransportCredentials(insecure.NewCredentials()),
        }
}</span>

func (c *Client) Run() error <span class="cov0" title="0">{
        conn, err := grpc.NewClient(c.host, c.dialOption)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.conn = conn
        c.client = proto.NewLomsServiceClient(conn)

        return nil</span>
}

func (c *Client) Close() <span class="cov0" title="0">{
        if c.conn != nil </span><span class="cov0" title="0">{
                c.conn.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package loms

import (
        "context"
        "fmt"

        "route256/cart/proto"
)

type OrderItem struct {
        SkuID    uint64
        Quantity uint32
}

func orderItemsToProto(items []OrderItem) []*proto.OrderItem <span class="cov0" title="0">{
        res := make([]*proto.OrderItem, len(items))

        for i, item := range items </span><span class="cov0" title="0">{
                res[i] = &amp;proto.OrderItem{
                        SkuId:    item.SkuID,
                        Quantity: item.Quantity,
                }
        }</span>

        <span class="cov0" title="0">return res</span>
}

func (c *Client) CreateOrder(ctx context.Context, userID int64, items []OrderItem) (int64, error) <span class="cov0" title="0">{
        req := &amp;proto.CreateOrderRequest{
                User:  userID,
                Items: orderItemsToProto(items),
        }

        res, err := c.client.CreateOrder(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create order: %w", err)
        }</span>

        <span class="cov0" title="0">return res.OrderID, nil</span>
}

func (c *Client) GetOrder(ctx context.Context, orderID int64) (*proto.OrderInfoResponse, error) <span class="cov0" title="0">{
        req := &amp;proto.OrderInfoRequest{
                OrderID: orderID,
        }

        res, err := c.client.GetOrder(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order: %w", err)
        }</span>

        <span class="cov0" title="0">return res, nil</span>
}

func (c *Client) GetStockInfo(ctx context.Context, sku uint32) (uint64, error) <span class="cov0" title="0">{
        req := &amp;proto.StockInfoRequest{
                Sku: sku,
        }

        res, err := c.client.GetStockInfo(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get stock info: %w", err)
        }</span>

        <span class="cov0" title="0">return res.Count, nil</span>
}

func (c *Client) OrderPay(ctx context.Context, orderID int64) error <span class="cov0" title="0">{
        req := &amp;proto.OrderPayRequest{
                OrderID: orderID,
        }
        _, err := c.client.OrderPay(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to pay for order: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Client) DeleteOrder(ctx context.Context, orderID int64) error <span class="cov0" title="0">{
        req := &amp;proto.OrderInfoRequest{
                OrderID: orderID,
        }
        _, err := c.client.DeleteOrder(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete order: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package product

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "route256/cart/cmd/config"
)

type Client struct {
        baseURL     string
        token       string
        client      *http.Client
        rateLimiter *time.Ticker
}

func NewClient(cfg config.ProductClient) (*Client, error) <span class="cov1" title="1">{
        productClientTimeout, err := time.ParseDuration(cfg.Timeout + "s")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse product client timeout: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;Client{
                baseURL:     cfg.Host,
                token:       cfg.Token,
                client:      &amp;http.Client{Timeout: productClientTimeout},
                rateLimiter: time.NewTicker(time.Second / time.Duration(cfg.Rps)),
        }, nil</span>
}

type Product struct {
        Name  string `json:"name"`
        Price uint32 `json:"price"`
}

type Response struct {
        Product
        Message string `json:"message"`
}

type Request struct {
        Token string `json:"token"`
        SkuID uint32 `json:"sku"`
}

func (c *Client) GetProduct(ctx context.Context, skuID uint32) (*Product, error) <span class="cov10" title="2">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        case &lt;-c.rateLimiter.C:<span class="cov10" title="2"></span>
        }

        <span class="cov10" title="2">url := fmt.Sprintf("%s/get_product", c.baseURL)

        requestBody, err := json.Marshal(Request{
                Token: c.token,
                SkuID: skuID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="2">req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(requestBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov10" title="2">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov10" title="2">defer resp.Body.Close() //nolint:errcheck

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get product: %s", resp.Status)
        }</span>

        <span class="cov10" title="2">var response Response
        if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="2">if response.Message == "sku not found" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("product not found")
        }</span>

        <span class="cov10" title="2">return &amp;response.Product, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.2
//         protoc        v5.27.0
// source: loms.proto

package proto

import (
        reflect "reflect"
        sync "sync"

        _ "github.com/envoyproxy/protoc-gen-validate/validate"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CreateOrderRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        User  int64        `protobuf:"varint,1,opt,name=user,proto3" json:"user,omitempty"`
        Items []*OrderItem `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty"`
}

func (x *CreateOrderRequest) Reset() <span class="cov0" title="0">{
        *x = CreateOrderRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_loms_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateOrderRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateOrderRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateOrderRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_loms_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateOrderRequest.ProtoReflect.Descriptor instead.
func (*CreateOrderRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_loms_proto_rawDescGZIP(), []int{0}
}</span>

func (x *CreateOrderRequest) GetUser() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CreateOrderRequest) GetItems() []*OrderItem <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateOrderResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        OrderID int64 `protobuf:"varint,1,opt,name=orderID,proto3" json:"orderID,omitempty"`
}

func (x *CreateOrderResponse) Reset() <span class="cov0" title="0">{
        *x = CreateOrderResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_loms_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateOrderResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateOrderResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateOrderResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_loms_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateOrderResponse.ProtoReflect.Descriptor instead.
func (*CreateOrderResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_loms_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CreateOrderResponse) GetOrderID() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type OrderInfoRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        OrderID int64 `protobuf:"varint,1,opt,name=orderID,proto3" json:"orderID,omitempty"`
}

func (x *OrderInfoRequest) Reset() <span class="cov0" title="0">{
        *x = OrderInfoRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_loms_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *OrderInfoRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderInfoRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderInfoRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_loms_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderInfoRequest.ProtoReflect.Descriptor instead.
func (*OrderInfoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_loms_proto_rawDescGZIP(), []int{2}
}</span>

func (x *OrderInfoRequest) GetOrderID() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type OrderInfoResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Status string       `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
        User   int64        `protobuf:"varint,2,opt,name=user,proto3" json:"user,omitempty"`
        Items  []*OrderItem `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty"`
}

func (x *OrderInfoResponse) Reset() <span class="cov0" title="0">{
        *x = OrderInfoResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_loms_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *OrderInfoResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderInfoResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderInfoResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_loms_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderInfoResponse.ProtoReflect.Descriptor instead.
func (*OrderInfoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_loms_proto_rawDescGZIP(), []int{3}
}</span>

func (x *OrderInfoResponse) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *OrderInfoResponse) GetUser() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *OrderInfoResponse) GetItems() []*OrderItem <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type StockInfoRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Sku uint32 `protobuf:"varint,1,opt,name=sku,proto3" json:"sku,omitempty"`
}

func (x *StockInfoRequest) Reset() <span class="cov0" title="0">{
        *x = StockInfoRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_loms_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StockInfoRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StockInfoRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StockInfoRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_loms_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StockInfoRequest.ProtoReflect.Descriptor instead.
func (*StockInfoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_loms_proto_rawDescGZIP(), []int{4}
}</span>

func (x *StockInfoRequest) GetSku() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sku
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type StockInfoResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
}

func (x *StockInfoResponse) Reset() <span class="cov0" title="0">{
        *x = StockInfoResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_loms_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StockInfoResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StockInfoResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StockInfoResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_loms_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StockInfoResponse.ProtoReflect.Descriptor instead.
func (*StockInfoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_loms_proto_rawDescGZIP(), []int{5}
}</span>

func (x *StockInfoResponse) GetCount() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Count
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type OrderPayRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        OrderID int64 `protobuf:"varint,1,opt,name=orderID,proto3" json:"orderID,omitempty"`
}

func (x *OrderPayRequest) Reset() <span class="cov0" title="0">{
        *x = OrderPayRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_loms_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *OrderPayRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderPayRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderPayRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_loms_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderPayRequest.ProtoReflect.Descriptor instead.
func (*OrderPayRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_loms_proto_rawDescGZIP(), []int{6}
}</span>

func (x *OrderPayRequest) GetOrderID() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type OrderItem struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        SkuId    uint64 `protobuf:"varint,1,opt,name=sku_id,json=skuId,proto3" json:"sku_id,omitempty"`
        Quantity uint32 `protobuf:"varint,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
}

func (x *OrderItem) Reset() <span class="cov0" title="0">{
        *x = OrderItem{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_loms_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *OrderItem) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderItem) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderItem) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_loms_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderItem.ProtoReflect.Descriptor instead.
func (*OrderItem) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_loms_proto_rawDescGZIP(), []int{7}
}</span>

func (x *OrderItem) GetSkuId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SkuId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *OrderItem) GetQuantity() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Quantity
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_loms_proto protoreflect.FileDescriptor

var file_loms_proto_rawDesc = []byte{
        0x0a, 0x0a, 0x6c, 0x6f, 0x6d, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x04, 0x6c, 0x6f,
        0x6d, 0x73, 0x1a, 0x17, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2f, 0x76, 0x61, 0x6c,
        0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1b, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65, 0x6d, 0x70,
        0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x62, 0x0a, 0x12, 0x43, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b,
        0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x42, 0x07, 0xfa, 0x42,
        0x04, 0x22, 0x02, 0x20, 0x00, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x2f, 0x0a, 0x05, 0x69,
        0x74, 0x65, 0x6d, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6c, 0x6f, 0x6d,
        0x73, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x74, 0x65, 0x6d, 0x42, 0x08, 0xfa, 0x42, 0x05,
        0x92, 0x01, 0x02, 0x08, 0x01, 0x52, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x2f, 0x0a, 0x13,
        0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x44, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x03, 0x52, 0x07, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x44, 0x22, 0x35, 0x0a,
        0x10, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x21, 0x0a, 0x07, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x03, 0x42, 0x07, 0xfa, 0x42, 0x04, 0x22, 0x02, 0x20, 0x00, 0x52, 0x07, 0x6f, 0x72, 0x64,
        0x65, 0x72, 0x49, 0x44, 0x22, 0x66, 0x0a, 0x11, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x6e, 0x66,
        0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61,
        0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75,
        0x73, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52,
        0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x25, 0x0a, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x03,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6c, 0x6f, 0x6d, 0x73, 0x2e, 0x4f, 0x72, 0x64, 0x65,
        0x72, 0x49, 0x74, 0x65, 0x6d, 0x52, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x22, 0x2d, 0x0a, 0x10,
        0x53, 0x74, 0x6f, 0x63, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x19, 0x0a, 0x03, 0x73, 0x6b, 0x75, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x42, 0x07, 0xfa,
        0x42, 0x04, 0x2a, 0x02, 0x20, 0x00, 0x52, 0x03, 0x73, 0x6b, 0x75, 0x22, 0x29, 0x0a, 0x11, 0x53,
        0x74, 0x6f, 0x63, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52,
        0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x34, 0x0a, 0x0f, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x50,
        0x61, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x21, 0x0a, 0x07, 0x6f, 0x72, 0x64,
        0x65, 0x72, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x42, 0x07, 0xfa, 0x42, 0x04, 0x22,
        0x02, 0x20, 0x00, 0x52, 0x07, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x44, 0x22, 0x50, 0x0a, 0x09,
        0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x74, 0x65, 0x6d, 0x12, 0x1e, 0x0a, 0x06, 0x73, 0x6b, 0x75,
        0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x42, 0x07, 0xfa, 0x42, 0x04, 0x72, 0x02,
        0x10, 0x01, 0x52, 0x05, 0x73, 0x6b, 0x75, 0x49, 0x64, 0x12, 0x23, 0x0a, 0x08, 0x71, 0x75, 0x61,
        0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x42, 0x07, 0xfa, 0x42, 0x04,
        0x2a, 0x02, 0x20, 0x00, 0x52, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x32, 0xc9,
        0x02, 0x0a, 0x0b, 0x4c, 0x6f, 0x6d, 0x73, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x42,
        0x0a, 0x0b, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x18, 0x2e,
        0x6c, 0x6f, 0x6d, 0x73, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x19, 0x2e, 0x6c, 0x6f, 0x6d, 0x73, 0x2e, 0x43,
        0x72, 0x65, 0x61, 0x74, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x3b, 0x0a, 0x08, 0x47, 0x65, 0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x16,
        0x2e, 0x6c, 0x6f, 0x6d, 0x73, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e, 0x6c, 0x6f, 0x6d, 0x73, 0x2e, 0x4f, 0x72,
        0x64, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x3f, 0x0a, 0x0c, 0x47, 0x65, 0x74, 0x53, 0x74, 0x6f, 0x63, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x12,
        0x16, 0x2e, 0x6c, 0x6f, 0x6d, 0x73, 0x2e, 0x53, 0x74, 0x6f, 0x63, 0x6b, 0x49, 0x6e, 0x66, 0x6f,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e, 0x6c, 0x6f, 0x6d, 0x73, 0x2e, 0x53,
        0x74, 0x6f, 0x63, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x39, 0x0a, 0x08, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x50, 0x61, 0x79, 0x12, 0x15, 0x2e, 0x6c,
        0x6f, 0x6d, 0x73, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x50, 0x61, 0x79, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x3d, 0x0a, 0x0b, 0x44,
        0x65, 0x6c, 0x65, 0x74, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x16, 0x2e, 0x6c, 0x6f, 0x6d,
        0x73, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x42, 0x15, 0x5a, 0x13, 0x72, 0x6f,
        0x75, 0x74, 0x65, 0x32, 0x35, 0x36, 0x2f, 0x6c, 0x6f, 0x6d, 0x73, 0x2f, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_loms_proto_rawDescOnce sync.Once
        file_loms_proto_rawDescData = file_loms_proto_rawDesc
)

func file_loms_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_loms_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_loms_proto_rawDescData = protoimpl.X.CompressGZIP(file_loms_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_loms_proto_rawDescData</span>
}

var file_loms_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_loms_proto_goTypes = []any{
        (*CreateOrderRequest)(nil),  // 0: loms.CreateOrderRequest
        (*CreateOrderResponse)(nil), // 1: loms.CreateOrderResponse
        (*OrderInfoRequest)(nil),    // 2: loms.OrderInfoRequest
        (*OrderInfoResponse)(nil),   // 3: loms.OrderInfoResponse
        (*StockInfoRequest)(nil),    // 4: loms.StockInfoRequest
        (*StockInfoResponse)(nil),   // 5: loms.StockInfoResponse
        (*OrderPayRequest)(nil),     // 6: loms.OrderPayRequest
        (*OrderItem)(nil),           // 7: loms.OrderItem
        (*emptypb.Empty)(nil),       // 8: google.protobuf.Empty
}
var file_loms_proto_depIdxs = []int32{
        7, // 0: loms.CreateOrderRequest.items:type_name -&gt; loms.OrderItem
        7, // 1: loms.OrderInfoResponse.items:type_name -&gt; loms.OrderItem
        0, // 2: loms.LomsService.CreateOrder:input_type -&gt; loms.CreateOrderRequest
        2, // 3: loms.LomsService.GetOrder:input_type -&gt; loms.OrderInfoRequest
        4, // 4: loms.LomsService.GetStockInfo:input_type -&gt; loms.StockInfoRequest
        6, // 5: loms.LomsService.OrderPay:input_type -&gt; loms.OrderPayRequest
        2, // 6: loms.LomsService.DeleteOrder:input_type -&gt; loms.OrderInfoRequest
        1, // 7: loms.LomsService.CreateOrder:output_type -&gt; loms.CreateOrderResponse
        3, // 8: loms.LomsService.GetOrder:output_type -&gt; loms.OrderInfoResponse
        5, // 9: loms.LomsService.GetStockInfo:output_type -&gt; loms.StockInfoResponse
        8, // 10: loms.LomsService.OrderPay:output_type -&gt; google.protobuf.Empty
        8, // 11: loms.LomsService.DeleteOrder:output_type -&gt; google.protobuf.Empty
        7, // [7:12] is the sub-list for method output_type
        2, // [2:7] is the sub-list for method input_type
        2, // [2:2] is the sub-list for extension type_name
        2, // [2:2] is the sub-list for extension extendee
        0, // [0:2] is the sub-list for field type_name
}

func init() <span class="cov10" title="3">{ file_loms_proto_init() }</span>
func file_loms_proto_init() <span class="cov10" title="3">{
        if File_loms_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="3">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_loms_proto_msgTypes[0].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CreateOrderRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_loms_proto_msgTypes[1].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CreateOrderResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_loms_proto_msgTypes[2].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*OrderInfoRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_loms_proto_msgTypes[3].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*OrderInfoResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_loms_proto_msgTypes[4].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*StockInfoRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_loms_proto_msgTypes[5].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*StockInfoResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_loms_proto_msgTypes[6].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*OrderPayRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_loms_proto_msgTypes[7].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*OrderItem); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov10" title="3">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_loms_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   8,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_loms_proto_goTypes,
                DependencyIndexes: file_loms_proto_depIdxs,
                MessageInfos:      file_loms_proto_msgTypes,
        }.Build()
        File_loms_proto = out.File
        file_loms_proto_rawDesc = nil
        file_loms_proto_goTypes = nil
        file_loms_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v5.27.0
// source: loms.proto

package proto

import (
        context "context"

        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
        LomsService_CreateOrder_FullMethodName  = "/loms.LomsService/CreateOrder"
        LomsService_GetOrder_FullMethodName     = "/loms.LomsService/GetOrder"
        LomsService_GetStockInfo_FullMethodName = "/loms.LomsService/GetStockInfo"
        LomsService_OrderPay_FullMethodName     = "/loms.LomsService/OrderPay"
        LomsService_DeleteOrder_FullMethodName  = "/loms.LomsService/DeleteOrder"
)

// LomsServiceClient is the client API for LomsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LomsServiceClient interface {
        CreateOrder(ctx context.Context, in *CreateOrderRequest, opts ...grpc.CallOption) (*CreateOrderResponse, error)
        GetOrder(ctx context.Context, in *OrderInfoRequest, opts ...grpc.CallOption) (*OrderInfoResponse, error)
        GetStockInfo(ctx context.Context, in *StockInfoRequest, opts ...grpc.CallOption) (*StockInfoResponse, error)
        OrderPay(ctx context.Context, in *OrderPayRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        DeleteOrder(ctx context.Context, in *OrderInfoRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type lomsServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewLomsServiceClient(cc grpc.ClientConnInterface) LomsServiceClient <span class="cov0" title="0">{
        return &amp;lomsServiceClient{cc}
}</span>

func (c *lomsServiceClient) CreateOrder(ctx context.Context, in *CreateOrderRequest, opts ...grpc.CallOption) (*CreateOrderResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateOrderResponse)
        err := c.cc.Invoke(ctx, LomsService_CreateOrder_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *lomsServiceClient) GetOrder(ctx context.Context, in *OrderInfoRequest, opts ...grpc.CallOption) (*OrderInfoResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(OrderInfoResponse)
        err := c.cc.Invoke(ctx, LomsService_GetOrder_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *lomsServiceClient) GetStockInfo(ctx context.Context, in *StockInfoRequest, opts ...grpc.CallOption) (*StockInfoResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StockInfoResponse)
        err := c.cc.Invoke(ctx, LomsService_GetStockInfo_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *lomsServiceClient) OrderPay(ctx context.Context, in *OrderPayRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, LomsService_OrderPay_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *lomsServiceClient) DeleteOrder(ctx context.Context, in *OrderInfoRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, LomsService_DeleteOrder_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// LomsServiceServer is the server API for LomsService service.
// All implementations must embed UnimplementedLomsServiceServer
// for forward compatibility
type LomsServiceServer interface {
        CreateOrder(context.Context, *CreateOrderRequest) (*CreateOrderResponse, error)
        GetOrder(context.Context, *OrderInfoRequest) (*OrderInfoResponse, error)
        GetStockInfo(context.Context, *StockInfoRequest) (*StockInfoResponse, error)
        OrderPay(context.Context, *OrderPayRequest) (*emptypb.Empty, error)
        DeleteOrder(context.Context, *OrderInfoRequest) (*emptypb.Empty, error)
        mustEmbedUnimplementedLomsServiceServer()
}

// UnimplementedLomsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLomsServiceServer struct {
}

func (UnimplementedLomsServiceServer) CreateOrder(context.Context, *CreateOrderRequest) (*CreateOrderResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateOrder not implemented")
}</span>
func (UnimplementedLomsServiceServer) GetOrder(context.Context, *OrderInfoRequest) (*OrderInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetOrder not implemented")
}</span>
func (UnimplementedLomsServiceServer) GetStockInfo(context.Context, *StockInfoRequest) (*StockInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetStockInfo not implemented")
}</span>
func (UnimplementedLomsServiceServer) OrderPay(context.Context, *OrderPayRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method OrderPay not implemented")
}</span>
func (UnimplementedLomsServiceServer) DeleteOrder(context.Context, *OrderInfoRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteOrder not implemented")
}</span>
func (UnimplementedLomsServiceServer) mustEmbedUnimplementedLomsServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeLomsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LomsServiceServer will
// result in compilation errors.
type UnsafeLomsServiceServer interface {
        mustEmbedUnimplementedLomsServiceServer()
}

func RegisterLomsServiceServer(s grpc.ServiceRegistrar, srv LomsServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;LomsService_ServiceDesc, srv)
}</span>

func _LomsService_CreateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateOrderRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LomsServiceServer).CreateOrder(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: LomsService_CreateOrder_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LomsServiceServer).CreateOrder(ctx, req.(*CreateOrderRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _LomsService_GetOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(OrderInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LomsServiceServer).GetOrder(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: LomsService_GetOrder_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LomsServiceServer).GetOrder(ctx, req.(*OrderInfoRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _LomsService_GetStockInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(StockInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LomsServiceServer).GetStockInfo(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: LomsService_GetStockInfo_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LomsServiceServer).GetStockInfo(ctx, req.(*StockInfoRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _LomsService_OrderPay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(OrderPayRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LomsServiceServer).OrderPay(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: LomsService_OrderPay_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LomsServiceServer).OrderPay(ctx, req.(*OrderPayRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _LomsService_DeleteOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(OrderInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(LomsServiceServer).DeleteOrder(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: LomsService_DeleteOrder_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(LomsServiceServer).DeleteOrder(ctx, req.(*OrderInfoRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// LomsService_ServiceDesc is the grpc.ServiceDesc for LomsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LomsService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "loms.LomsService",
        HandlerType: (*LomsServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateOrder",
                        Handler:    _LomsService_CreateOrder_Handler,
                },
                {
                        MethodName: "GetOrder",
                        Handler:    _LomsService_GetOrder_Handler,
                },
                {
                        MethodName: "GetStockInfo",
                        Handler:    _LomsService_GetStockInfo_Handler,
                },
                {
                        MethodName: "OrderPay",
                        Handler:    _LomsService_OrderPay_Handler,
                },
                {
                        MethodName: "DeleteOrder",
                        Handler:    _LomsService_DeleteOrder_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "loms.proto",
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handler

import (
        "net/http"
        "net/http/httptest"

        "route256/cart/cmd/config"
        "route256/cart/internal/handler"
        "route256/cart/internal/repository"
        "route256/cart/internal/service"
        "route256/cart/internal/service/mocks"
        "route256/cart/pkg/product"

        "github.com/joho/godotenv"
        "github.com/stretchr/testify/suite"
        "go.uber.org/goleak"
)

type TestSuite struct {
        suite.Suite
        server  *httptest.Server
        repo    *repository.Repository
        service *service.Service
        handler *handler.Handler
}

func (suite *TestSuite) SetupSuite() <span class="cov8" title="1">{
        err := godotenv.Load("../../.env")
        if err != nil </span><span class="cov0" title="0">{
                suite.T().Fatalf("Error loading .env file: %v", err)
        }</span>

        <span class="cov8" title="1">cfg, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                suite.T().Fatalf("Failed to parse config: %v", err)
        }</span>

        <span class="cov8" title="1">productClient, err := product.NewClient(cfg.ProductClient)
        if err != nil </span><span class="cov0" title="0">{
                suite.T().Fatalf("Failed to parse product client: %v", err)
        }</span>

        <span class="cov8" title="1">lomsClientMock := mocks.NewLomsClientMock(suite.T())

        repo := repository.NewRepository()
        svc := service.NewService(repo, productClient, lomsClientMock)
        handlers := handler.NewHandler(svc)

        mux := http.NewServeMux()
        handlers.RegisterRoutes(mux)

        suite.repo = repo
        suite.service = svc
        suite.handler = handlers

        server := httptest.NewServer(mux)

        suite.server = server</span>
}

func (suite *TestSuite) TearDownSuite() <span class="cov8" title="1">{
        suite.server.Close()
        goleak.VerifyNone(suite.T())
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
