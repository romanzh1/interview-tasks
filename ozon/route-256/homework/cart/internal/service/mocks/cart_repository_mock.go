// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/cart/internal/service.cartRepository -o cart_repository_mock.go -n CartRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"route256/cart/internal/models"

	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements service.cartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItemToUserCart          func(ctx context.Context, cart models.CartRequest) (err error)
	inspectFuncAddItemToUserCart   func(ctx context.Context, cart models.CartRequest)
	afterAddItemToUserCartCounter  uint64
	beforeAddItemToUserCartCounter uint64
	AddItemToUserCartMock          mCartRepositoryMockAddItemToUserCart

	funcClearUserCart          func(ctx context.Context, userID int64) (err error)
	inspectFuncClearUserCart   func(ctx context.Context, userID int64)
	afterClearUserCartCounter  uint64
	beforeClearUserCartCounter uint64
	ClearUserCartMock          mCartRepositoryMockClearUserCart

	funcDeleteItemFromUserCart          func(ctx context.Context, userID int64, skuID int64) (err error)
	inspectFuncDeleteItemFromUserCart   func(ctx context.Context, userID int64, skuID int64)
	afterDeleteItemFromUserCartCounter  uint64
	beforeDeleteItemFromUserCartCounter uint64
	DeleteItemFromUserCartMock          mCartRepositoryMockDeleteItemFromUserCart

	funcListUserCart          func(ctx context.Context, userID int64) (ca1 []models.CartItem, err error)
	inspectFuncListUserCart   func(ctx context.Context, userID int64)
	afterListUserCartCounter  uint64
	beforeListUserCartCounter uint64
	ListUserCartMock          mCartRepositoryMockListUserCart
}

// NewCartRepositoryMock returns a mock for service.cartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemToUserCartMock = mCartRepositoryMockAddItemToUserCart{mock: m}
	m.AddItemToUserCartMock.callArgs = []*CartRepositoryMockAddItemToUserCartParams{}

	m.ClearUserCartMock = mCartRepositoryMockClearUserCart{mock: m}
	m.ClearUserCartMock.callArgs = []*CartRepositoryMockClearUserCartParams{}

	m.DeleteItemFromUserCartMock = mCartRepositoryMockDeleteItemFromUserCart{mock: m}
	m.DeleteItemFromUserCartMock.callArgs = []*CartRepositoryMockDeleteItemFromUserCartParams{}

	m.ListUserCartMock = mCartRepositoryMockListUserCart{mock: m}
	m.ListUserCartMock.callArgs = []*CartRepositoryMockListUserCartParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockAddItemToUserCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockAddItemToUserCartExpectation
	expectations       []*CartRepositoryMockAddItemToUserCartExpectation

	callArgs []*CartRepositoryMockAddItemToUserCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartRepositoryMockAddItemToUserCartExpectation specifies expectation struct of the cartRepository.AddItemToUserCart
type CartRepositoryMockAddItemToUserCartExpectation struct {
	mock      *CartRepositoryMock
	params    *CartRepositoryMockAddItemToUserCartParams
	paramPtrs *CartRepositoryMockAddItemToUserCartParamPtrs
	results   *CartRepositoryMockAddItemToUserCartResults
	Counter   uint64
}

// CartRepositoryMockAddItemToUserCartParams contains parameters of the cartRepository.AddItemToUserCart
type CartRepositoryMockAddItemToUserCartParams struct {
	ctx  context.Context
	cart models.CartRequest
}

// CartRepositoryMockAddItemToUserCartParamPtrs contains pointers to parameters of the cartRepository.AddItemToUserCart
type CartRepositoryMockAddItemToUserCartParamPtrs struct {
	ctx  *context.Context
	cart *models.CartRequest
}

// CartRepositoryMockAddItemToUserCartResults contains results of the cartRepository.AddItemToUserCart
type CartRepositoryMockAddItemToUserCartResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Optional() *mCartRepositoryMockAddItemToUserCart {
	mmAddItemToUserCart.optional = true
	return mmAddItemToUserCart
}

// Expect sets up expected params for cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Expect(ctx context.Context, cart models.CartRequest) *mCartRepositoryMockAddItemToUserCart {
	if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil {
		mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
	}

	if mmAddItemToUserCart.defaultExpectation == nil {
		mmAddItemToUserCart.defaultExpectation = &CartRepositoryMockAddItemToUserCartExpectation{}
	}

	if mmAddItemToUserCart.defaultExpectation.paramPtrs != nil {
		mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by ExpectParams functions")
	}

	mmAddItemToUserCart.defaultExpectation.params = &CartRepositoryMockAddItemToUserCartParams{ctx, cart}
	for _, e := range mmAddItemToUserCart.expectations {
		if minimock.Equal(e.params, mmAddItemToUserCart.defaultExpectation.params) {
			mmAddItemToUserCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItemToUserCart.defaultExpectation.params)
		}
	}

	return mmAddItemToUserCart
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockAddItemToUserCart {
	if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil {
		mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
	}

	if mmAddItemToUserCart.defaultExpectation == nil {
		mmAddItemToUserCart.defaultExpectation = &CartRepositoryMockAddItemToUserCartExpectation{}
	}

	if mmAddItemToUserCart.defaultExpectation.params != nil {
		mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Expect")
	}

	if mmAddItemToUserCart.defaultExpectation.paramPtrs == nil {
		mmAddItemToUserCart.defaultExpectation.paramPtrs = &CartRepositoryMockAddItemToUserCartParamPtrs{}
	}
	mmAddItemToUserCart.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddItemToUserCart
}

// ExpectCartParam2 sets up expected param cart for cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) ExpectCartParam2(cart models.CartRequest) *mCartRepositoryMockAddItemToUserCart {
	if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil {
		mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
	}

	if mmAddItemToUserCart.defaultExpectation == nil {
		mmAddItemToUserCart.defaultExpectation = &CartRepositoryMockAddItemToUserCartExpectation{}
	}

	if mmAddItemToUserCart.defaultExpectation.params != nil {
		mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Expect")
	}

	if mmAddItemToUserCart.defaultExpectation.paramPtrs == nil {
		mmAddItemToUserCart.defaultExpectation.paramPtrs = &CartRepositoryMockAddItemToUserCartParamPtrs{}
	}
	mmAddItemToUserCart.defaultExpectation.paramPtrs.cart = &cart

	return mmAddItemToUserCart
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Inspect(f func(ctx context.Context, cart models.CartRequest)) *mCartRepositoryMockAddItemToUserCart {
	if mmAddItemToUserCart.mock.inspectFuncAddItemToUserCart != nil {
		mmAddItemToUserCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.AddItemToUserCart")
	}

	mmAddItemToUserCart.mock.inspectFuncAddItemToUserCart = f

	return mmAddItemToUserCart
}

// Return sets up results that will be returned by cartRepository.AddItemToUserCart
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Return(err error) *CartRepositoryMock {
	if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil {
		mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
	}

	if mmAddItemToUserCart.defaultExpectation == nil {
		mmAddItemToUserCart.defaultExpectation = &CartRepositoryMockAddItemToUserCartExpectation{mock: mmAddItemToUserCart.mock}
	}
	mmAddItemToUserCart.defaultExpectation.results = &CartRepositoryMockAddItemToUserCartResults{err}
	return mmAddItemToUserCart.mock
}

// Set uses given function f to mock the cartRepository.AddItemToUserCart method
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Set(f func(ctx context.Context, cart models.CartRequest) (err error)) *CartRepositoryMock {
	if mmAddItemToUserCart.defaultExpectation != nil {
		mmAddItemToUserCart.mock.t.Fatalf("Default expectation is already set for the cartRepository.AddItemToUserCart method")
	}

	if len(mmAddItemToUserCart.expectations) > 0 {
		mmAddItemToUserCart.mock.t.Fatalf("Some expectations are already set for the cartRepository.AddItemToUserCart method")
	}

	mmAddItemToUserCart.mock.funcAddItemToUserCart = f
	return mmAddItemToUserCart.mock
}

// When sets expectation for the cartRepository.AddItemToUserCart which will trigger the result defined by the following
// Then helper
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) When(ctx context.Context, cart models.CartRequest) *CartRepositoryMockAddItemToUserCartExpectation {
	if mmAddItemToUserCart.mock.funcAddItemToUserCart != nil {
		mmAddItemToUserCart.mock.t.Fatalf("CartRepositoryMock.AddItemToUserCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockAddItemToUserCartExpectation{
		mock:   mmAddItemToUserCart.mock,
		params: &CartRepositoryMockAddItemToUserCartParams{ctx, cart},
	}
	mmAddItemToUserCart.expectations = append(mmAddItemToUserCart.expectations, expectation)
	return expectation
}

// Then sets up cartRepository.AddItemToUserCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddItemToUserCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockAddItemToUserCartResults{err}
	return e.mock
}

// Times sets number of times cartRepository.AddItemToUserCart should be invoked
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Times(n uint64) *mCartRepositoryMockAddItemToUserCart {
	if n == 0 {
		mmAddItemToUserCart.mock.t.Fatalf("Times of CartRepositoryMock.AddItemToUserCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItemToUserCart.expectedInvocations, n)
	return mmAddItemToUserCart
}

func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) invocationsDone() bool {
	if len(mmAddItemToUserCart.expectations) == 0 && mmAddItemToUserCart.defaultExpectation == nil && mmAddItemToUserCart.mock.funcAddItemToUserCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItemToUserCart.mock.afterAddItemToUserCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItemToUserCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItemToUserCart implements service.cartRepository
func (mmAddItemToUserCart *CartRepositoryMock) AddItemToUserCart(ctx context.Context, cart models.CartRequest) (err error) {
	mm_atomic.AddUint64(&mmAddItemToUserCart.beforeAddItemToUserCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItemToUserCart.afterAddItemToUserCartCounter, 1)

	if mmAddItemToUserCart.inspectFuncAddItemToUserCart != nil {
		mmAddItemToUserCart.inspectFuncAddItemToUserCart(ctx, cart)
	}

	mm_params := CartRepositoryMockAddItemToUserCartParams{ctx, cart}

	// Record call args
	mmAddItemToUserCart.AddItemToUserCartMock.mutex.Lock()
	mmAddItemToUserCart.AddItemToUserCartMock.callArgs = append(mmAddItemToUserCart.AddItemToUserCartMock.callArgs, &mm_params)
	mmAddItemToUserCart.AddItemToUserCartMock.mutex.Unlock()

	for _, e := range mmAddItemToUserCart.AddItemToUserCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation.params
		mm_want_ptrs := mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockAddItemToUserCartParams{ctx, cart}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItemToUserCart.t.Errorf("CartRepositoryMock.AddItemToUserCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cart != nil && !minimock.Equal(*mm_want_ptrs.cart, mm_got.cart) {
				mmAddItemToUserCart.t.Errorf("CartRepositoryMock.AddItemToUserCart got unexpected parameter cart, want: %#v, got: %#v%s\n", *mm_want_ptrs.cart, mm_got.cart, minimock.Diff(*mm_want_ptrs.cart, mm_got.cart))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItemToUserCart.t.Errorf("CartRepositoryMock.AddItemToUserCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItemToUserCart.AddItemToUserCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItemToUserCart.t.Fatal("No results are set for the CartRepositoryMock.AddItemToUserCart")
		}
		return (*mm_results).err
	}
	if mmAddItemToUserCart.funcAddItemToUserCart != nil {
		return mmAddItemToUserCart.funcAddItemToUserCart(ctx, cart)
	}
	mmAddItemToUserCart.t.Fatalf("Unexpected call to CartRepositoryMock.AddItemToUserCart. %v %v", ctx, cart)
	return
}

// AddItemToUserCartAfterCounter returns a count of finished CartRepositoryMock.AddItemToUserCart invocations
func (mmAddItemToUserCart *CartRepositoryMock) AddItemToUserCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItemToUserCart.afterAddItemToUserCartCounter)
}

// AddItemToUserCartBeforeCounter returns a count of CartRepositoryMock.AddItemToUserCart invocations
func (mmAddItemToUserCart *CartRepositoryMock) AddItemToUserCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItemToUserCart.beforeAddItemToUserCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.AddItemToUserCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItemToUserCart *mCartRepositoryMockAddItemToUserCart) Calls() []*CartRepositoryMockAddItemToUserCartParams {
	mmAddItemToUserCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockAddItemToUserCartParams, len(mmAddItemToUserCart.callArgs))
	copy(argCopy, mmAddItemToUserCart.callArgs)

	mmAddItemToUserCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemToUserCartDone returns true if the count of the AddItemToUserCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddItemToUserCartDone() bool {
	if m.AddItemToUserCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemToUserCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemToUserCartMock.invocationsDone()
}

// MinimockAddItemToUserCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddItemToUserCartInspect() {
	for _, e := range m.AddItemToUserCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.AddItemToUserCart with params: %#v", *e.params)
		}
	}

	afterAddItemToUserCartCounter := mm_atomic.LoadUint64(&m.afterAddItemToUserCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemToUserCartMock.defaultExpectation != nil && afterAddItemToUserCartCounter < 1 {
		if m.AddItemToUserCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.AddItemToUserCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.AddItemToUserCart with params: %#v", *m.AddItemToUserCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItemToUserCart != nil && afterAddItemToUserCartCounter < 1 {
		m.t.Error("Expected call to CartRepositoryMock.AddItemToUserCart")
	}

	if !m.AddItemToUserCartMock.invocationsDone() && afterAddItemToUserCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.AddItemToUserCart but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemToUserCartMock.expectedInvocations), afterAddItemToUserCartCounter)
	}
}

type mCartRepositoryMockClearUserCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockClearUserCartExpectation
	expectations       []*CartRepositoryMockClearUserCartExpectation

	callArgs []*CartRepositoryMockClearUserCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartRepositoryMockClearUserCartExpectation specifies expectation struct of the cartRepository.ClearUserCart
type CartRepositoryMockClearUserCartExpectation struct {
	mock      *CartRepositoryMock
	params    *CartRepositoryMockClearUserCartParams
	paramPtrs *CartRepositoryMockClearUserCartParamPtrs
	results   *CartRepositoryMockClearUserCartResults
	Counter   uint64
}

// CartRepositoryMockClearUserCartParams contains parameters of the cartRepository.ClearUserCart
type CartRepositoryMockClearUserCartParams struct {
	ctx    context.Context
	userID int64
}

// CartRepositoryMockClearUserCartParamPtrs contains pointers to parameters of the cartRepository.ClearUserCart
type CartRepositoryMockClearUserCartParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// CartRepositoryMockClearUserCartResults contains results of the cartRepository.ClearUserCart
type CartRepositoryMockClearUserCartResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Optional() *mCartRepositoryMockClearUserCart {
	mmClearUserCart.optional = true
	return mmClearUserCart
}

// Expect sets up expected params for cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Expect(ctx context.Context, userID int64) *mCartRepositoryMockClearUserCart {
	if mmClearUserCart.mock.funcClearUserCart != nil {
		mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
	}

	if mmClearUserCart.defaultExpectation == nil {
		mmClearUserCart.defaultExpectation = &CartRepositoryMockClearUserCartExpectation{}
	}

	if mmClearUserCart.defaultExpectation.paramPtrs != nil {
		mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by ExpectParams functions")
	}

	mmClearUserCart.defaultExpectation.params = &CartRepositoryMockClearUserCartParams{ctx, userID}
	for _, e := range mmClearUserCart.expectations {
		if minimock.Equal(e.params, mmClearUserCart.defaultExpectation.params) {
			mmClearUserCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearUserCart.defaultExpectation.params)
		}
	}

	return mmClearUserCart
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockClearUserCart {
	if mmClearUserCart.mock.funcClearUserCart != nil {
		mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
	}

	if mmClearUserCart.defaultExpectation == nil {
		mmClearUserCart.defaultExpectation = &CartRepositoryMockClearUserCartExpectation{}
	}

	if mmClearUserCart.defaultExpectation.params != nil {
		mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Expect")
	}

	if mmClearUserCart.defaultExpectation.paramPtrs == nil {
		mmClearUserCart.defaultExpectation.paramPtrs = &CartRepositoryMockClearUserCartParamPtrs{}
	}
	mmClearUserCart.defaultExpectation.paramPtrs.ctx = &ctx

	return mmClearUserCart
}

// ExpectUserIDParam2 sets up expected param userID for cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) ExpectUserIDParam2(userID int64) *mCartRepositoryMockClearUserCart {
	if mmClearUserCart.mock.funcClearUserCart != nil {
		mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
	}

	if mmClearUserCart.defaultExpectation == nil {
		mmClearUserCart.defaultExpectation = &CartRepositoryMockClearUserCartExpectation{}
	}

	if mmClearUserCart.defaultExpectation.params != nil {
		mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Expect")
	}

	if mmClearUserCart.defaultExpectation.paramPtrs == nil {
		mmClearUserCart.defaultExpectation.paramPtrs = &CartRepositoryMockClearUserCartParamPtrs{}
	}
	mmClearUserCart.defaultExpectation.paramPtrs.userID = &userID

	return mmClearUserCart
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Inspect(f func(ctx context.Context, userID int64)) *mCartRepositoryMockClearUserCart {
	if mmClearUserCart.mock.inspectFuncClearUserCart != nil {
		mmClearUserCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ClearUserCart")
	}

	mmClearUserCart.mock.inspectFuncClearUserCart = f

	return mmClearUserCart
}

// Return sets up results that will be returned by cartRepository.ClearUserCart
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Return(err error) *CartRepositoryMock {
	if mmClearUserCart.mock.funcClearUserCart != nil {
		mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
	}

	if mmClearUserCart.defaultExpectation == nil {
		mmClearUserCart.defaultExpectation = &CartRepositoryMockClearUserCartExpectation{mock: mmClearUserCart.mock}
	}
	mmClearUserCart.defaultExpectation.results = &CartRepositoryMockClearUserCartResults{err}
	return mmClearUserCart.mock
}

// Set uses given function f to mock the cartRepository.ClearUserCart method
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Set(f func(ctx context.Context, userID int64) (err error)) *CartRepositoryMock {
	if mmClearUserCart.defaultExpectation != nil {
		mmClearUserCart.mock.t.Fatalf("Default expectation is already set for the cartRepository.ClearUserCart method")
	}

	if len(mmClearUserCart.expectations) > 0 {
		mmClearUserCart.mock.t.Fatalf("Some expectations are already set for the cartRepository.ClearUserCart method")
	}

	mmClearUserCart.mock.funcClearUserCart = f
	return mmClearUserCart.mock
}

// When sets expectation for the cartRepository.ClearUserCart which will trigger the result defined by the following
// Then helper
func (mmClearUserCart *mCartRepositoryMockClearUserCart) When(ctx context.Context, userID int64) *CartRepositoryMockClearUserCartExpectation {
	if mmClearUserCart.mock.funcClearUserCart != nil {
		mmClearUserCart.mock.t.Fatalf("CartRepositoryMock.ClearUserCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockClearUserCartExpectation{
		mock:   mmClearUserCart.mock,
		params: &CartRepositoryMockClearUserCartParams{ctx, userID},
	}
	mmClearUserCart.expectations = append(mmClearUserCart.expectations, expectation)
	return expectation
}

// Then sets up cartRepository.ClearUserCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockClearUserCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockClearUserCartResults{err}
	return e.mock
}

// Times sets number of times cartRepository.ClearUserCart should be invoked
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Times(n uint64) *mCartRepositoryMockClearUserCart {
	if n == 0 {
		mmClearUserCart.mock.t.Fatalf("Times of CartRepositoryMock.ClearUserCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClearUserCart.expectedInvocations, n)
	return mmClearUserCart
}

func (mmClearUserCart *mCartRepositoryMockClearUserCart) invocationsDone() bool {
	if len(mmClearUserCart.expectations) == 0 && mmClearUserCart.defaultExpectation == nil && mmClearUserCart.mock.funcClearUserCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClearUserCart.mock.afterClearUserCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClearUserCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ClearUserCart implements service.cartRepository
func (mmClearUserCart *CartRepositoryMock) ClearUserCart(ctx context.Context, userID int64) (err error) {
	mm_atomic.AddUint64(&mmClearUserCart.beforeClearUserCartCounter, 1)
	defer mm_atomic.AddUint64(&mmClearUserCart.afterClearUserCartCounter, 1)

	if mmClearUserCart.inspectFuncClearUserCart != nil {
		mmClearUserCart.inspectFuncClearUserCart(ctx, userID)
	}

	mm_params := CartRepositoryMockClearUserCartParams{ctx, userID}

	// Record call args
	mmClearUserCart.ClearUserCartMock.mutex.Lock()
	mmClearUserCart.ClearUserCartMock.callArgs = append(mmClearUserCart.ClearUserCartMock.callArgs, &mm_params)
	mmClearUserCart.ClearUserCartMock.mutex.Unlock()

	for _, e := range mmClearUserCart.ClearUserCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClearUserCart.ClearUserCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearUserCart.ClearUserCartMock.defaultExpectation.Counter, 1)
		mm_want := mmClearUserCart.ClearUserCartMock.defaultExpectation.params
		mm_want_ptrs := mmClearUserCart.ClearUserCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockClearUserCartParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClearUserCart.t.Errorf("CartRepositoryMock.ClearUserCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmClearUserCart.t.Errorf("CartRepositoryMock.ClearUserCart got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearUserCart.t.Errorf("CartRepositoryMock.ClearUserCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearUserCart.ClearUserCartMock.defaultExpectation.results
		if mm_results == nil {
			mmClearUserCart.t.Fatal("No results are set for the CartRepositoryMock.ClearUserCart")
		}
		return (*mm_results).err
	}
	if mmClearUserCart.funcClearUserCart != nil {
		return mmClearUserCart.funcClearUserCart(ctx, userID)
	}
	mmClearUserCart.t.Fatalf("Unexpected call to CartRepositoryMock.ClearUserCart. %v %v", ctx, userID)
	return
}

// ClearUserCartAfterCounter returns a count of finished CartRepositoryMock.ClearUserCart invocations
func (mmClearUserCart *CartRepositoryMock) ClearUserCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearUserCart.afterClearUserCartCounter)
}

// ClearUserCartBeforeCounter returns a count of CartRepositoryMock.ClearUserCart invocations
func (mmClearUserCart *CartRepositoryMock) ClearUserCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearUserCart.beforeClearUserCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.ClearUserCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearUserCart *mCartRepositoryMockClearUserCart) Calls() []*CartRepositoryMockClearUserCartParams {
	mmClearUserCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockClearUserCartParams, len(mmClearUserCart.callArgs))
	copy(argCopy, mmClearUserCart.callArgs)

	mmClearUserCart.mutex.RUnlock()

	return argCopy
}

// MinimockClearUserCartDone returns true if the count of the ClearUserCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockClearUserCartDone() bool {
	if m.ClearUserCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearUserCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearUserCartMock.invocationsDone()
}

// MinimockClearUserCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockClearUserCartInspect() {
	for _, e := range m.ClearUserCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearUserCart with params: %#v", *e.params)
		}
	}

	afterClearUserCartCounter := mm_atomic.LoadUint64(&m.afterClearUserCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearUserCartMock.defaultExpectation != nil && afterClearUserCartCounter < 1 {
		if m.ClearUserCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.ClearUserCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearUserCart with params: %#v", *m.ClearUserCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearUserCart != nil && afterClearUserCartCounter < 1 {
		m.t.Error("Expected call to CartRepositoryMock.ClearUserCart")
	}

	if !m.ClearUserCartMock.invocationsDone() && afterClearUserCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.ClearUserCart but found %d calls",
			mm_atomic.LoadUint64(&m.ClearUserCartMock.expectedInvocations), afterClearUserCartCounter)
	}
}

type mCartRepositoryMockDeleteItemFromUserCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteItemFromUserCartExpectation
	expectations       []*CartRepositoryMockDeleteItemFromUserCartExpectation

	callArgs []*CartRepositoryMockDeleteItemFromUserCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartRepositoryMockDeleteItemFromUserCartExpectation specifies expectation struct of the cartRepository.DeleteItemFromUserCart
type CartRepositoryMockDeleteItemFromUserCartExpectation struct {
	mock      *CartRepositoryMock
	params    *CartRepositoryMockDeleteItemFromUserCartParams
	paramPtrs *CartRepositoryMockDeleteItemFromUserCartParamPtrs
	results   *CartRepositoryMockDeleteItemFromUserCartResults
	Counter   uint64
}

// CartRepositoryMockDeleteItemFromUserCartParams contains parameters of the cartRepository.DeleteItemFromUserCart
type CartRepositoryMockDeleteItemFromUserCartParams struct {
	ctx    context.Context
	userID int64
	skuID  int64
}

// CartRepositoryMockDeleteItemFromUserCartParamPtrs contains pointers to parameters of the cartRepository.DeleteItemFromUserCart
type CartRepositoryMockDeleteItemFromUserCartParamPtrs struct {
	ctx    *context.Context
	userID *int64
	skuID  *int64
}

// CartRepositoryMockDeleteItemFromUserCartResults contains results of the cartRepository.DeleteItemFromUserCart
type CartRepositoryMockDeleteItemFromUserCartResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Optional() *mCartRepositoryMockDeleteItemFromUserCart {
	mmDeleteItemFromUserCart.optional = true
	return mmDeleteItemFromUserCart
}

// Expect sets up expected params for cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Expect(ctx context.Context, userID int64, skuID int64) *mCartRepositoryMockDeleteItemFromUserCart {
	if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil {
		mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
	}

	if mmDeleteItemFromUserCart.defaultExpectation == nil {
		mmDeleteItemFromUserCart.defaultExpectation = &CartRepositoryMockDeleteItemFromUserCartExpectation{}
	}

	if mmDeleteItemFromUserCart.defaultExpectation.paramPtrs != nil {
		mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by ExpectParams functions")
	}

	mmDeleteItemFromUserCart.defaultExpectation.params = &CartRepositoryMockDeleteItemFromUserCartParams{ctx, userID, skuID}
	for _, e := range mmDeleteItemFromUserCart.expectations {
		if minimock.Equal(e.params, mmDeleteItemFromUserCart.defaultExpectation.params) {
			mmDeleteItemFromUserCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItemFromUserCart.defaultExpectation.params)
		}
	}

	return mmDeleteItemFromUserCart
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDeleteItemFromUserCart {
	if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil {
		mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
	}

	if mmDeleteItemFromUserCart.defaultExpectation == nil {
		mmDeleteItemFromUserCart.defaultExpectation = &CartRepositoryMockDeleteItemFromUserCartExpectation{}
	}

	if mmDeleteItemFromUserCart.defaultExpectation.params != nil {
		mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Expect")
	}

	if mmDeleteItemFromUserCart.defaultExpectation.paramPtrs == nil {
		mmDeleteItemFromUserCart.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemFromUserCartParamPtrs{}
	}
	mmDeleteItemFromUserCart.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteItemFromUserCart
}

// ExpectUserIDParam2 sets up expected param userID for cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) ExpectUserIDParam2(userID int64) *mCartRepositoryMockDeleteItemFromUserCart {
	if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil {
		mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
	}

	if mmDeleteItemFromUserCart.defaultExpectation == nil {
		mmDeleteItemFromUserCart.defaultExpectation = &CartRepositoryMockDeleteItemFromUserCartExpectation{}
	}

	if mmDeleteItemFromUserCart.defaultExpectation.params != nil {
		mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Expect")
	}

	if mmDeleteItemFromUserCart.defaultExpectation.paramPtrs == nil {
		mmDeleteItemFromUserCart.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemFromUserCartParamPtrs{}
	}
	mmDeleteItemFromUserCart.defaultExpectation.paramPtrs.userID = &userID

	return mmDeleteItemFromUserCart
}

// ExpectSkuIDParam3 sets up expected param skuID for cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) ExpectSkuIDParam3(skuID int64) *mCartRepositoryMockDeleteItemFromUserCart {
	if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil {
		mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
	}

	if mmDeleteItemFromUserCart.defaultExpectation == nil {
		mmDeleteItemFromUserCart.defaultExpectation = &CartRepositoryMockDeleteItemFromUserCartExpectation{}
	}

	if mmDeleteItemFromUserCart.defaultExpectation.params != nil {
		mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Expect")
	}

	if mmDeleteItemFromUserCart.defaultExpectation.paramPtrs == nil {
		mmDeleteItemFromUserCart.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemFromUserCartParamPtrs{}
	}
	mmDeleteItemFromUserCart.defaultExpectation.paramPtrs.skuID = &skuID

	return mmDeleteItemFromUserCart
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Inspect(f func(ctx context.Context, userID int64, skuID int64)) *mCartRepositoryMockDeleteItemFromUserCart {
	if mmDeleteItemFromUserCart.mock.inspectFuncDeleteItemFromUserCart != nil {
		mmDeleteItemFromUserCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteItemFromUserCart")
	}

	mmDeleteItemFromUserCart.mock.inspectFuncDeleteItemFromUserCart = f

	return mmDeleteItemFromUserCart
}

// Return sets up results that will be returned by cartRepository.DeleteItemFromUserCart
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Return(err error) *CartRepositoryMock {
	if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil {
		mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
	}

	if mmDeleteItemFromUserCart.defaultExpectation == nil {
		mmDeleteItemFromUserCart.defaultExpectation = &CartRepositoryMockDeleteItemFromUserCartExpectation{mock: mmDeleteItemFromUserCart.mock}
	}
	mmDeleteItemFromUserCart.defaultExpectation.results = &CartRepositoryMockDeleteItemFromUserCartResults{err}
	return mmDeleteItemFromUserCart.mock
}

// Set uses given function f to mock the cartRepository.DeleteItemFromUserCart method
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Set(f func(ctx context.Context, userID int64, skuID int64) (err error)) *CartRepositoryMock {
	if mmDeleteItemFromUserCart.defaultExpectation != nil {
		mmDeleteItemFromUserCart.mock.t.Fatalf("Default expectation is already set for the cartRepository.DeleteItemFromUserCart method")
	}

	if len(mmDeleteItemFromUserCart.expectations) > 0 {
		mmDeleteItemFromUserCart.mock.t.Fatalf("Some expectations are already set for the cartRepository.DeleteItemFromUserCart method")
	}

	mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart = f
	return mmDeleteItemFromUserCart.mock
}

// When sets expectation for the cartRepository.DeleteItemFromUserCart which will trigger the result defined by the following
// Then helper
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) When(ctx context.Context, userID int64, skuID int64) *CartRepositoryMockDeleteItemFromUserCartExpectation {
	if mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart != nil {
		mmDeleteItemFromUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteItemFromUserCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteItemFromUserCartExpectation{
		mock:   mmDeleteItemFromUserCart.mock,
		params: &CartRepositoryMockDeleteItemFromUserCartParams{ctx, userID, skuID},
	}
	mmDeleteItemFromUserCart.expectations = append(mmDeleteItemFromUserCart.expectations, expectation)
	return expectation
}

// Then sets up cartRepository.DeleteItemFromUserCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteItemFromUserCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteItemFromUserCartResults{err}
	return e.mock
}

// Times sets number of times cartRepository.DeleteItemFromUserCart should be invoked
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Times(n uint64) *mCartRepositoryMockDeleteItemFromUserCart {
	if n == 0 {
		mmDeleteItemFromUserCart.mock.t.Fatalf("Times of CartRepositoryMock.DeleteItemFromUserCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItemFromUserCart.expectedInvocations, n)
	return mmDeleteItemFromUserCart
}

func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) invocationsDone() bool {
	if len(mmDeleteItemFromUserCart.expectations) == 0 && mmDeleteItemFromUserCart.defaultExpectation == nil && mmDeleteItemFromUserCart.mock.funcDeleteItemFromUserCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItemFromUserCart.mock.afterDeleteItemFromUserCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItemFromUserCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItemFromUserCart implements service.cartRepository
func (mmDeleteItemFromUserCart *CartRepositoryMock) DeleteItemFromUserCart(ctx context.Context, userID int64, skuID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteItemFromUserCart.beforeDeleteItemFromUserCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItemFromUserCart.afterDeleteItemFromUserCartCounter, 1)

	if mmDeleteItemFromUserCart.inspectFuncDeleteItemFromUserCart != nil {
		mmDeleteItemFromUserCart.inspectFuncDeleteItemFromUserCart(ctx, userID, skuID)
	}

	mm_params := CartRepositoryMockDeleteItemFromUserCartParams{ctx, userID, skuID}

	// Record call args
	mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.mutex.Lock()
	mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.callArgs = append(mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.callArgs, &mm_params)
	mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.mutex.Unlock()

	for _, e := range mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDeleteItemFromUserCartParams{ctx, userID, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItemFromUserCart.t.Errorf("CartRepositoryMock.DeleteItemFromUserCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteItemFromUserCart.t.Errorf("CartRepositoryMock.DeleteItemFromUserCart got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmDeleteItemFromUserCart.t.Errorf("CartRepositoryMock.DeleteItemFromUserCart got unexpected parameter skuID, want: %#v, got: %#v%s\n", *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItemFromUserCart.t.Errorf("CartRepositoryMock.DeleteItemFromUserCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItemFromUserCart.DeleteItemFromUserCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItemFromUserCart.t.Fatal("No results are set for the CartRepositoryMock.DeleteItemFromUserCart")
		}
		return (*mm_results).err
	}
	if mmDeleteItemFromUserCart.funcDeleteItemFromUserCart != nil {
		return mmDeleteItemFromUserCart.funcDeleteItemFromUserCart(ctx, userID, skuID)
	}
	mmDeleteItemFromUserCart.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteItemFromUserCart. %v %v %v", ctx, userID, skuID)
	return
}

// DeleteItemFromUserCartAfterCounter returns a count of finished CartRepositoryMock.DeleteItemFromUserCart invocations
func (mmDeleteItemFromUserCart *CartRepositoryMock) DeleteItemFromUserCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemFromUserCart.afterDeleteItemFromUserCartCounter)
}

// DeleteItemFromUserCartBeforeCounter returns a count of CartRepositoryMock.DeleteItemFromUserCart invocations
func (mmDeleteItemFromUserCart *CartRepositoryMock) DeleteItemFromUserCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemFromUserCart.beforeDeleteItemFromUserCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteItemFromUserCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItemFromUserCart *mCartRepositoryMockDeleteItemFromUserCart) Calls() []*CartRepositoryMockDeleteItemFromUserCartParams {
	mmDeleteItemFromUserCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteItemFromUserCartParams, len(mmDeleteItemFromUserCart.callArgs))
	copy(argCopy, mmDeleteItemFromUserCart.callArgs)

	mmDeleteItemFromUserCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemFromUserCartDone returns true if the count of the DeleteItemFromUserCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteItemFromUserCartDone() bool {
	if m.DeleteItemFromUserCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemFromUserCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemFromUserCartMock.invocationsDone()
}

// MinimockDeleteItemFromUserCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteItemFromUserCartInspect() {
	for _, e := range m.DeleteItemFromUserCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItemFromUserCart with params: %#v", *e.params)
		}
	}

	afterDeleteItemFromUserCartCounter := mm_atomic.LoadUint64(&m.afterDeleteItemFromUserCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemFromUserCartMock.defaultExpectation != nil && afterDeleteItemFromUserCartCounter < 1 {
		if m.DeleteItemFromUserCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.DeleteItemFromUserCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItemFromUserCart with params: %#v", *m.DeleteItemFromUserCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemFromUserCart != nil && afterDeleteItemFromUserCartCounter < 1 {
		m.t.Error("Expected call to CartRepositoryMock.DeleteItemFromUserCart")
	}

	if !m.DeleteItemFromUserCartMock.invocationsDone() && afterDeleteItemFromUserCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteItemFromUserCart but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemFromUserCartMock.expectedInvocations), afterDeleteItemFromUserCartCounter)
	}
}

type mCartRepositoryMockListUserCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockListUserCartExpectation
	expectations       []*CartRepositoryMockListUserCartExpectation

	callArgs []*CartRepositoryMockListUserCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartRepositoryMockListUserCartExpectation specifies expectation struct of the cartRepository.ListUserCart
type CartRepositoryMockListUserCartExpectation struct {
	mock      *CartRepositoryMock
	params    *CartRepositoryMockListUserCartParams
	paramPtrs *CartRepositoryMockListUserCartParamPtrs
	results   *CartRepositoryMockListUserCartResults
	Counter   uint64
}

// CartRepositoryMockListUserCartParams contains parameters of the cartRepository.ListUserCart
type CartRepositoryMockListUserCartParams struct {
	ctx    context.Context
	userID int64
}

// CartRepositoryMockListUserCartParamPtrs contains pointers to parameters of the cartRepository.ListUserCart
type CartRepositoryMockListUserCartParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// CartRepositoryMockListUserCartResults contains results of the cartRepository.ListUserCart
type CartRepositoryMockListUserCartResults struct {
	ca1 []models.CartItem
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListUserCart *mCartRepositoryMockListUserCart) Optional() *mCartRepositoryMockListUserCart {
	mmListUserCart.optional = true
	return mmListUserCart
}

// Expect sets up expected params for cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) Expect(ctx context.Context, userID int64) *mCartRepositoryMockListUserCart {
	if mmListUserCart.mock.funcListUserCart != nil {
		mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
	}

	if mmListUserCart.defaultExpectation == nil {
		mmListUserCart.defaultExpectation = &CartRepositoryMockListUserCartExpectation{}
	}

	if mmListUserCart.defaultExpectation.paramPtrs != nil {
		mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by ExpectParams functions")
	}

	mmListUserCart.defaultExpectation.params = &CartRepositoryMockListUserCartParams{ctx, userID}
	for _, e := range mmListUserCart.expectations {
		if minimock.Equal(e.params, mmListUserCart.defaultExpectation.params) {
			mmListUserCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListUserCart.defaultExpectation.params)
		}
	}

	return mmListUserCart
}

// ExpectCtxParam1 sets up expected param ctx for cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockListUserCart {
	if mmListUserCart.mock.funcListUserCart != nil {
		mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
	}

	if mmListUserCart.defaultExpectation == nil {
		mmListUserCart.defaultExpectation = &CartRepositoryMockListUserCartExpectation{}
	}

	if mmListUserCart.defaultExpectation.params != nil {
		mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Expect")
	}

	if mmListUserCart.defaultExpectation.paramPtrs == nil {
		mmListUserCart.defaultExpectation.paramPtrs = &CartRepositoryMockListUserCartParamPtrs{}
	}
	mmListUserCart.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListUserCart
}

// ExpectUserIDParam2 sets up expected param userID for cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) ExpectUserIDParam2(userID int64) *mCartRepositoryMockListUserCart {
	if mmListUserCart.mock.funcListUserCart != nil {
		mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
	}

	if mmListUserCart.defaultExpectation == nil {
		mmListUserCart.defaultExpectation = &CartRepositoryMockListUserCartExpectation{}
	}

	if mmListUserCart.defaultExpectation.params != nil {
		mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Expect")
	}

	if mmListUserCart.defaultExpectation.paramPtrs == nil {
		mmListUserCart.defaultExpectation.paramPtrs = &CartRepositoryMockListUserCartParamPtrs{}
	}
	mmListUserCart.defaultExpectation.paramPtrs.userID = &userID

	return mmListUserCart
}

// Inspect accepts an inspector function that has same arguments as the cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) Inspect(f func(ctx context.Context, userID int64)) *mCartRepositoryMockListUserCart {
	if mmListUserCart.mock.inspectFuncListUserCart != nil {
		mmListUserCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ListUserCart")
	}

	mmListUserCart.mock.inspectFuncListUserCart = f

	return mmListUserCart
}

// Return sets up results that will be returned by cartRepository.ListUserCart
func (mmListUserCart *mCartRepositoryMockListUserCart) Return(ca1 []models.CartItem, err error) *CartRepositoryMock {
	if mmListUserCart.mock.funcListUserCart != nil {
		mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
	}

	if mmListUserCart.defaultExpectation == nil {
		mmListUserCart.defaultExpectation = &CartRepositoryMockListUserCartExpectation{mock: mmListUserCart.mock}
	}
	mmListUserCart.defaultExpectation.results = &CartRepositoryMockListUserCartResults{ca1, err}
	return mmListUserCart.mock
}

// Set uses given function f to mock the cartRepository.ListUserCart method
func (mmListUserCart *mCartRepositoryMockListUserCart) Set(f func(ctx context.Context, userID int64) (ca1 []models.CartItem, err error)) *CartRepositoryMock {
	if mmListUserCart.defaultExpectation != nil {
		mmListUserCart.mock.t.Fatalf("Default expectation is already set for the cartRepository.ListUserCart method")
	}

	if len(mmListUserCart.expectations) > 0 {
		mmListUserCart.mock.t.Fatalf("Some expectations are already set for the cartRepository.ListUserCart method")
	}

	mmListUserCart.mock.funcListUserCart = f
	return mmListUserCart.mock
}

// When sets expectation for the cartRepository.ListUserCart which will trigger the result defined by the following
// Then helper
func (mmListUserCart *mCartRepositoryMockListUserCart) When(ctx context.Context, userID int64) *CartRepositoryMockListUserCartExpectation {
	if mmListUserCart.mock.funcListUserCart != nil {
		mmListUserCart.mock.t.Fatalf("CartRepositoryMock.ListUserCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockListUserCartExpectation{
		mock:   mmListUserCart.mock,
		params: &CartRepositoryMockListUserCartParams{ctx, userID},
	}
	mmListUserCart.expectations = append(mmListUserCart.expectations, expectation)
	return expectation
}

// Then sets up cartRepository.ListUserCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockListUserCartExpectation) Then(ca1 []models.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockListUserCartResults{ca1, err}
	return e.mock
}

// Times sets number of times cartRepository.ListUserCart should be invoked
func (mmListUserCart *mCartRepositoryMockListUserCart) Times(n uint64) *mCartRepositoryMockListUserCart {
	if n == 0 {
		mmListUserCart.mock.t.Fatalf("Times of CartRepositoryMock.ListUserCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListUserCart.expectedInvocations, n)
	return mmListUserCart
}

func (mmListUserCart *mCartRepositoryMockListUserCart) invocationsDone() bool {
	if len(mmListUserCart.expectations) == 0 && mmListUserCart.defaultExpectation == nil && mmListUserCart.mock.funcListUserCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListUserCart.mock.afterListUserCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListUserCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListUserCart implements service.cartRepository
func (mmListUserCart *CartRepositoryMock) ListUserCart(ctx context.Context, userID int64) (ca1 []models.CartItem, err error) {
	mm_atomic.AddUint64(&mmListUserCart.beforeListUserCartCounter, 1)
	defer mm_atomic.AddUint64(&mmListUserCart.afterListUserCartCounter, 1)

	if mmListUserCart.inspectFuncListUserCart != nil {
		mmListUserCart.inspectFuncListUserCart(ctx, userID)
	}

	mm_params := CartRepositoryMockListUserCartParams{ctx, userID}

	// Record call args
	mmListUserCart.ListUserCartMock.mutex.Lock()
	mmListUserCart.ListUserCartMock.callArgs = append(mmListUserCart.ListUserCartMock.callArgs, &mm_params)
	mmListUserCart.ListUserCartMock.mutex.Unlock()

	for _, e := range mmListUserCart.ListUserCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmListUserCart.ListUserCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListUserCart.ListUserCartMock.defaultExpectation.Counter, 1)
		mm_want := mmListUserCart.ListUserCartMock.defaultExpectation.params
		mm_want_ptrs := mmListUserCart.ListUserCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockListUserCartParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListUserCart.t.Errorf("CartRepositoryMock.ListUserCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmListUserCart.t.Errorf("CartRepositoryMock.ListUserCart got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListUserCart.t.Errorf("CartRepositoryMock.ListUserCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListUserCart.ListUserCartMock.defaultExpectation.results
		if mm_results == nil {
			mmListUserCart.t.Fatal("No results are set for the CartRepositoryMock.ListUserCart")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmListUserCart.funcListUserCart != nil {
		return mmListUserCart.funcListUserCart(ctx, userID)
	}
	mmListUserCart.t.Fatalf("Unexpected call to CartRepositoryMock.ListUserCart. %v %v", ctx, userID)
	return
}

// ListUserCartAfterCounter returns a count of finished CartRepositoryMock.ListUserCart invocations
func (mmListUserCart *CartRepositoryMock) ListUserCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUserCart.afterListUserCartCounter)
}

// ListUserCartBeforeCounter returns a count of CartRepositoryMock.ListUserCart invocations
func (mmListUserCart *CartRepositoryMock) ListUserCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUserCart.beforeListUserCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.ListUserCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListUserCart *mCartRepositoryMockListUserCart) Calls() []*CartRepositoryMockListUserCartParams {
	mmListUserCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockListUserCartParams, len(mmListUserCart.callArgs))
	copy(argCopy, mmListUserCart.callArgs)

	mmListUserCart.mutex.RUnlock()

	return argCopy
}

// MinimockListUserCartDone returns true if the count of the ListUserCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockListUserCartDone() bool {
	if m.ListUserCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListUserCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListUserCartMock.invocationsDone()
}

// MinimockListUserCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockListUserCartInspect() {
	for _, e := range m.ListUserCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.ListUserCart with params: %#v", *e.params)
		}
	}

	afterListUserCartCounter := mm_atomic.LoadUint64(&m.afterListUserCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListUserCartMock.defaultExpectation != nil && afterListUserCartCounter < 1 {
		if m.ListUserCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.ListUserCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.ListUserCart with params: %#v", *m.ListUserCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListUserCart != nil && afterListUserCartCounter < 1 {
		m.t.Error("Expected call to CartRepositoryMock.ListUserCart")
	}

	if !m.ListUserCartMock.invocationsDone() && afterListUserCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.ListUserCart but found %d calls",
			mm_atomic.LoadUint64(&m.ListUserCartMock.expectedInvocations), afterListUserCartCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemToUserCartInspect()

			m.MinimockClearUserCartInspect()

			m.MinimockDeleteItemFromUserCartInspect()

			m.MinimockListUserCartInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemToUserCartDone() &&
		m.MinimockClearUserCartDone() &&
		m.MinimockDeleteItemFromUserCartDone() &&
		m.MinimockListUserCartDone()
}
