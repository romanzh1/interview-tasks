Задача 1

// Задача 1 написать функцию не создавая новый слайс
// [1,2,3,4,5] -> [1,3,5]
// [2,2,2] -> []
// [1,2,2] -> [1]
func filter(a []int) []int {

}

Задача 2
// Предлагаю реализовать вариант rate limiter соответствующего интерфейсу Limiter
// Основной концепт заключается в том, что у нас есть некоторая корзина токенов для каждого ключа key, при вызове метода Allow мы уменьшаем количество токенов на 1.
// Если количество токенов стало равным 0, возвращаем false, в остальных случаях нужно вернуть true .
// Токены начисляются с некоторой скоростью, скажем n в сек для каждого ключа. Также существует некоторое максимальное значение токенов, выше которого токены не начисляются.

// Пример, максимальное количество токенов для ключа 5, за каждую секунду начисляется 5 токенов, за каждый запрос списывается 1 токен.
// Это значит, что мы можем делать 5 запросов в секунду.

// Многопоточку можно подумать
// Горутины здесь не потребуются
// Мы можем хранить время последнего захода в функцию по ключу и при новом вызове вычислять дельту между текущим временем и сохраненным. Исходя из этого начислять токены
//  Единица округления, единица расчета секунды. Если дельта 0сек, то нчиего не начисляем.

type Limiter interface {
	Allow(key string) bool
}